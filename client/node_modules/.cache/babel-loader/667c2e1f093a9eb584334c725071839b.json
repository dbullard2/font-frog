{"ast":null,"code":"// The Glyph object\nimport check from './check';\nimport draw from './draw';\nimport Path from './path'; // import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n  var _path = path || new Path();\n\n  return {\n    configurable: true,\n    get: function get() {\n      if (typeof _path === 'function') {\n        _path = _path();\n      }\n\n      return _path;\n    },\n    set: function set(p) {\n      _path = p;\n    }\n  };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\n\n\nfunction Glyph(options) {\n  // By putting all the code on a prototype function (which is only declared once)\n  // we reduce the memory requirements for larger fonts by some 2%\n  this.bindConstructorValues(options);\n}\n/**\n * @param  {GlyphOptions}\n */\n\n\nGlyph.prototype.bindConstructorValues = function (options) {\n  this.index = options.index || 0; // These three values cannot be deferred for memory optimization:\n\n  this.name = options.name || null;\n  this.unicode = options.unicode || undefined;\n  this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : []; // But by binding these values only when necessary, we reduce can\n  // the memory requirements by almost 3% for larger fonts.\n\n  if (options.xMin) {\n    this.xMin = options.xMin;\n  }\n\n  if (options.yMin) {\n    this.yMin = options.yMin;\n  }\n\n  if (options.xMax) {\n    this.xMax = options.xMax;\n  }\n\n  if (options.yMax) {\n    this.yMax = options.yMax;\n  }\n\n  if (options.advanceWidth) {\n    this.advanceWidth = options.advanceWidth;\n  } // The path for a glyph is the most memory intensive, and is bound as a value\n  // with a getter/setter to ensure we actually do path parsing only once the\n  // path is actually needed by anything.\n\n\n  Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n/**\n * @param {number}\n */\n\n\nGlyph.prototype.addUnicode = function (unicode) {\n  if (this.unicodes.length === 0) {\n    this.unicode = unicode;\n  }\n\n  this.unicodes.push(unicode);\n};\n/**\n * Calculate the minimum bounding box for this glyph.\n * @return {opentype.BoundingBox}\n */\n\n\nGlyph.prototype.getBoundingBox = function () {\n  return this.path.getBoundingBox();\n};\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\n\n\nGlyph.prototype.getPath = function (x, y, fontSize, options, font) {\n  x = x !== undefined ? x : 0;\n  y = y !== undefined ? y : 0;\n  fontSize = fontSize !== undefined ? fontSize : 72;\n  var commands;\n  var hPoints;\n  if (!options) options = {};\n  var xScale = options.xScale;\n  var yScale = options.yScale;\n\n  if (options.hinting && font && font.hinting) {\n    // in case of hinting, the hinting engine takes care\n    // of scaling the points (not the path) before hinting.\n    hPoints = this.path && font.hinting.exec(this, fontSize); // in case the hinting engine failed hPoints is undefined\n    // and thus reverts to plain rending\n  }\n\n  if (hPoints) {\n    // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n    commands = font.hinting.getCommands(hPoints);\n    x = Math.round(x);\n    y = Math.round(y); // TODO in case of hinting xyScaling is not yet supported\n\n    xScale = yScale = 1;\n  } else {\n    commands = this.path.commands;\n    var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n    if (xScale === undefined) xScale = scale;\n    if (yScale === undefined) yScale = scale;\n  }\n\n  var p = new Path();\n\n  for (var i = 0; i < commands.length; i += 1) {\n    var cmd = commands[i];\n\n    if (cmd.type === 'M') {\n      p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n    } else if (cmd.type === 'L') {\n      p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n    } else if (cmd.type === 'Q') {\n      p.quadraticCurveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);\n    } else if (cmd.type === 'C') {\n      p.curveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x2 * xScale, y + -cmd.y2 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);\n    } else if (cmd.type === 'Z') {\n      p.closePath();\n    }\n  }\n\n  return p;\n};\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\n\n\nGlyph.prototype.getContours = function () {\n  if (this.points === undefined) {\n    return [];\n  }\n\n  var contours = [];\n  var currentContour = [];\n\n  for (var i = 0; i < this.points.length; i += 1) {\n    var pt = this.points[i];\n    currentContour.push(pt);\n\n    if (pt.lastPointOfContour) {\n      contours.push(currentContour);\n      currentContour = [];\n    }\n  }\n\n  check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n  return contours;\n};\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\n\n\nGlyph.prototype.getMetrics = function () {\n  var commands = this.path.commands;\n  var xCoords = [];\n  var yCoords = [];\n\n  for (var i = 0; i < commands.length; i += 1) {\n    var cmd = commands[i];\n\n    if (cmd.type !== 'Z') {\n      xCoords.push(cmd.x);\n      yCoords.push(cmd.y);\n    }\n\n    if (cmd.type === 'Q' || cmd.type === 'C') {\n      xCoords.push(cmd.x1);\n      yCoords.push(cmd.y1);\n    }\n\n    if (cmd.type === 'C') {\n      xCoords.push(cmd.x2);\n      yCoords.push(cmd.y2);\n    }\n  }\n\n  var metrics = {\n    xMin: Math.min.apply(null, xCoords),\n    yMin: Math.min.apply(null, yCoords),\n    xMax: Math.max.apply(null, xCoords),\n    yMax: Math.max.apply(null, yCoords),\n    leftSideBearing: this.leftSideBearing\n  };\n\n  if (!isFinite(metrics.xMin)) {\n    metrics.xMin = 0;\n  }\n\n  if (!isFinite(metrics.xMax)) {\n    metrics.xMax = this.advanceWidth;\n  }\n\n  if (!isFinite(metrics.yMin)) {\n    metrics.yMin = 0;\n  }\n\n  if (!isFinite(metrics.yMax)) {\n    metrics.yMax = 0;\n  }\n\n  metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n  return metrics;\n};\n/**\n * Draw the glyph on the given context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n */\n\n\nGlyph.prototype.draw = function (ctx, x, y, fontSize, options) {\n  this.getPath(x, y, fontSize, options).draw(ctx);\n};\n/**\n * Draw the points of the glyph.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\n\n\nGlyph.prototype.drawPoints = function (ctx, x, y, fontSize) {\n  function drawCircles(l, x, y, scale) {\n    var PI_SQ = Math.PI * 2;\n    ctx.beginPath();\n\n    for (var j = 0; j < l.length; j += 1) {\n      ctx.moveTo(x + l[j].x * scale, y + l[j].y * scale);\n      ctx.arc(x + l[j].x * scale, y + l[j].y * scale, 2, 0, PI_SQ, false);\n    }\n\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  x = x !== undefined ? x : 0;\n  y = y !== undefined ? y : 0;\n  fontSize = fontSize !== undefined ? fontSize : 24;\n  var scale = 1 / this.path.unitsPerEm * fontSize;\n  var blueCircles = [];\n  var redCircles = [];\n  var path = this.path;\n\n  for (var i = 0; i < path.commands.length; i += 1) {\n    var cmd = path.commands[i];\n\n    if (cmd.x !== undefined) {\n      blueCircles.push({\n        x: cmd.x,\n        y: -cmd.y\n      });\n    }\n\n    if (cmd.x1 !== undefined) {\n      redCircles.push({\n        x: cmd.x1,\n        y: -cmd.y1\n      });\n    }\n\n    if (cmd.x2 !== undefined) {\n      redCircles.push({\n        x: cmd.x2,\n        y: -cmd.y2\n      });\n    }\n  }\n\n  ctx.fillStyle = 'blue';\n  drawCircles(blueCircles, x, y, scale);\n  ctx.fillStyle = 'red';\n  drawCircles(redCircles, x, y, scale);\n};\n/**\n * Draw lines indicating important font measurements.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\n\n\nGlyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {\n  var scale;\n  x = x !== undefined ? x : 0;\n  y = y !== undefined ? y : 0;\n  fontSize = fontSize !== undefined ? fontSize : 24;\n  scale = 1 / this.path.unitsPerEm * fontSize;\n  ctx.lineWidth = 1; // Draw the origin\n\n  ctx.strokeStyle = 'black';\n  draw.line(ctx, x, -10000, x, 10000);\n  draw.line(ctx, -10000, y, 10000, y); // This code is here due to memory optimization: by not using\n  // defaults in the constructor, we save a notable amount of memory.\n\n  var xMin = this.xMin || 0;\n  var yMin = this.yMin || 0;\n  var xMax = this.xMax || 0;\n  var yMax = this.yMax || 0;\n  var advanceWidth = this.advanceWidth || 0; // Draw the glyph box\n\n  ctx.strokeStyle = 'blue';\n  draw.line(ctx, x + xMin * scale, -10000, x + xMin * scale, 10000);\n  draw.line(ctx, x + xMax * scale, -10000, x + xMax * scale, 10000);\n  draw.line(ctx, -10000, y + -yMin * scale, 10000, y + -yMin * scale);\n  draw.line(ctx, -10000, y + -yMax * scale, 10000, y + -yMax * scale); // Draw the advance width\n\n  ctx.strokeStyle = 'green';\n  draw.line(ctx, x + advanceWidth * scale, -10000, x + advanceWidth * scale, 10000);\n};\n\nexport default Glyph;","map":null,"metadata":{},"sourceType":"module"}