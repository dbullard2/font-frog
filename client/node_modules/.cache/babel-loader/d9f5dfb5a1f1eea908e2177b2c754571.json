{"ast":null,"code":"// Table metadata\nimport check from './check';\nimport { encode, sizeOf } from './types';\n/**\n * @exports opentype.Table\n * @class\n * @param {string} tableName\n * @param {Array} fields\n * @param {Object} options\n * @constructor\n */\n\nfunction Table(tableName, fields, options) {\n  for (var i = 0; i < fields.length; i += 1) {\n    var field = fields[i];\n    this[field.name] = field.value;\n  }\n\n  this.tableName = tableName;\n  this.fields = fields;\n\n  if (options) {\n    var optionKeys = Object.keys(options);\n\n    for (var _i = 0; _i < optionKeys.length; _i += 1) {\n      var k = optionKeys[_i];\n      var v = options[k];\n\n      if (this[k] !== undefined) {\n        this[k] = v;\n      }\n    }\n  }\n}\n/**\n * Encodes the table and returns an array of bytes\n * @return {Array}\n */\n\n\nTable.prototype.encode = function () {\n  return encode.TABLE(this);\n};\n/**\n * Get the size of the table.\n * @return {number}\n */\n\n\nTable.prototype.sizeOf = function () {\n  return sizeOf.TABLE(this);\n};\n/**\n * @private\n */\n\n\nfunction ushortList(itemName, list, count) {\n  if (count === undefined) {\n    count = list.length;\n  }\n\n  var fields = new Array(list.length + 1);\n  fields[0] = {\n    name: itemName + 'Count',\n    type: 'USHORT',\n    value: count\n  };\n\n  for (var i = 0; i < list.length; i++) {\n    fields[i + 1] = {\n      name: itemName + i,\n      type: 'USHORT',\n      value: list[i]\n    };\n  }\n\n  return fields;\n}\n/**\n * @private\n */\n\n\nfunction tableList(itemName, records, itemCallback) {\n  var count = records.length;\n  var fields = new Array(count + 1);\n  fields[0] = {\n    name: itemName + 'Count',\n    type: 'USHORT',\n    value: count\n  };\n\n  for (var i = 0; i < count; i++) {\n    fields[i + 1] = {\n      name: itemName + i,\n      type: 'TABLE',\n      value: itemCallback(records[i], i)\n    };\n  }\n\n  return fields;\n}\n/**\n * @private\n */\n\n\nfunction recordList(itemName, records, itemCallback) {\n  var count = records.length;\n  var fields = [];\n  fields[0] = {\n    name: itemName + 'Count',\n    type: 'USHORT',\n    value: count\n  };\n\n  for (var i = 0; i < count; i++) {\n    fields = fields.concat(itemCallback(records[i], i));\n  }\n\n  return fields;\n} // Common Layout Tables\n\n/**\n * @exports opentype.Coverage\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\n\n\nfunction Coverage(coverageTable) {\n  if (coverageTable.format === 1) {\n    Table.call(this, 'coverageTable', [{\n      name: 'coverageFormat',\n      type: 'USHORT',\n      value: 1\n    }].concat(ushortList('glyph', coverageTable.glyphs)));\n  } else {\n    check.assert(false, 'Can\\'t create coverage table format 2 yet.');\n  }\n}\n\nCoverage.prototype = Object.create(Table.prototype);\nCoverage.prototype.constructor = Coverage;\n\nfunction ScriptList(scriptListTable) {\n  Table.call(this, 'scriptListTable', recordList('scriptRecord', scriptListTable, function (scriptRecord, i) {\n    var script = scriptRecord.script;\n    var defaultLangSys = script.defaultLangSys;\n    check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n    return [{\n      name: 'scriptTag' + i,\n      type: 'TAG',\n      value: scriptRecord.tag\n    }, {\n      name: 'script' + i,\n      type: 'TABLE',\n      value: new Table('scriptTable', [{\n        name: 'defaultLangSys',\n        type: 'TABLE',\n        value: new Table('defaultLangSys', [{\n          name: 'lookupOrder',\n          type: 'USHORT',\n          value: 0\n        }, {\n          name: 'reqFeatureIndex',\n          type: 'USHORT',\n          value: defaultLangSys.reqFeatureIndex\n        }].concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))\n      }].concat(recordList('langSys', script.langSysRecords, function (langSysRecord, i) {\n        var langSys = langSysRecord.langSys;\n        return [{\n          name: 'langSysTag' + i,\n          type: 'TAG',\n          value: langSysRecord.tag\n        }, {\n          name: 'langSys' + i,\n          type: 'TABLE',\n          value: new Table('langSys', [{\n            name: 'lookupOrder',\n            type: 'USHORT',\n            value: 0\n          }, {\n            name: 'reqFeatureIndex',\n            type: 'USHORT',\n            value: langSys.reqFeatureIndex\n          }].concat(ushortList('featureIndex', langSys.featureIndexes)))\n        }];\n      })))\n    }];\n  }));\n}\n\nScriptList.prototype = Object.create(Table.prototype);\nScriptList.prototype.constructor = ScriptList;\n/**\n * @exports opentype.FeatureList\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\n\nfunction FeatureList(featureListTable) {\n  Table.call(this, 'featureListTable', recordList('featureRecord', featureListTable, function (featureRecord, i) {\n    var feature = featureRecord.feature;\n    return [{\n      name: 'featureTag' + i,\n      type: 'TAG',\n      value: featureRecord.tag\n    }, {\n      name: 'feature' + i,\n      type: 'TABLE',\n      value: new Table('featureTable', [{\n        name: 'featureParams',\n        type: 'USHORT',\n        value: feature.featureParams\n      }].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))\n    }];\n  }));\n}\n\nFeatureList.prototype = Object.create(Table.prototype);\nFeatureList.prototype.constructor = FeatureList;\n/**\n * @exports opentype.LookupList\n * @class\n * @param {opentype.Table}\n * @param {Object}\n * @constructor\n * @extends opentype.Table\n */\n\nfunction LookupList(lookupListTable, subtableMakers) {\n  Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function (lookupTable) {\n    var subtableCallback = subtableMakers[lookupTable.lookupType];\n    check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n    return new Table('lookupTable', [{\n      name: 'lookupType',\n      type: 'USHORT',\n      value: lookupTable.lookupType\n    }, {\n      name: 'lookupFlag',\n      type: 'USHORT',\n      value: lookupTable.lookupFlag\n    }].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n  }));\n}\n\nLookupList.prototype = Object.create(Table.prototype);\nLookupList.prototype.constructor = LookupList; // Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n// Don't use offsets inside Records (probable bug), only in Tables.\n\nexport default {\n  Table: Table,\n  Record: Table,\n  Coverage: Coverage,\n  ScriptList: ScriptList,\n  FeatureList: FeatureList,\n  LookupList: LookupList,\n  ushortList: ushortList,\n  tableList: tableList,\n  recordList: recordList\n};","map":null,"metadata":{},"sourceType":"module"}