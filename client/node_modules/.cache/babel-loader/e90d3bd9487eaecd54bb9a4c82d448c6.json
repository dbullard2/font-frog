{"ast":null,"code":"/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\nimport { ContextParams } from '../tokenizer';\nimport { isTashkeelArabicChar } from '../char';\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\n\nfunction FeatureQuery(font) {\n  this.font = font;\n  this.features = {};\n}\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\n\n\nfunction SubstitutionAction(action) {\n  this.id = action.id;\n  this.tag = action.tag;\n  this.substitution = action.substitution;\n}\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\n\n\nfunction lookupCoverage(glyphIndex, coverage) {\n  if (!glyphIndex) return -1;\n\n  switch (coverage.format) {\n    case 1:\n      return coverage.glyphs.indexOf(glyphIndex);\n\n    case 2:\n      var ranges = coverage.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        if (glyphIndex >= range.start && glyphIndex <= range.end) {\n          var offset = glyphIndex - range.start;\n          return range.index + offset;\n        }\n      }\n\n      break;\n\n    default:\n      return -1;\n    // not found\n  }\n\n  return -1;\n}\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\n\n\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n  if (substituteIndex === -1) return null;\n  return glyphIndex + subtable.deltaGlyphId;\n}\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\n\n\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n  if (substituteIndex === -1) return null;\n  return subtable.substitute[substituteIndex];\n}\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\n\n\nfunction lookupCoverageList(coverageList, contextParams) {\n  var lookupList = [];\n\n  for (var i = 0; i < coverageList.length; i++) {\n    var coverage = coverageList[i];\n    var glyphIndex = contextParams.current;\n    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n    var lookupIndex = lookupCoverage(glyphIndex, coverage);\n\n    if (lookupIndex !== -1) {\n      lookupList.push(lookupIndex);\n    }\n  }\n\n  if (lookupList.length !== coverageList.length) return -1;\n  return lookupList;\n}\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\n\n\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n  var lookupsCount = subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length;\n  if (contextParams.context.length < lookupsCount) return []; // INPUT LOOKUP //\n\n  var inputLookups = lookupCoverageList(subtable.inputCoverage, contextParams);\n  if (inputLookups === -1) return []; // LOOKAHEAD LOOKUP //\n\n  var lookaheadOffset = subtable.inputCoverage.length - 1;\n  if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) return [];\n  var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n\n  while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n    lookaheadContext.shift();\n  }\n\n  var lookaheadParams = new ContextParams(lookaheadContext, 0);\n  var lookaheadLookups = lookupCoverageList(subtable.lookaheadCoverage, lookaheadParams); // BACKTRACK LOOKUP //\n\n  var backtrackContext = [].concat(contextParams.backtrack);\n  backtrackContext.reverse();\n\n  while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n    backtrackContext.shift();\n  }\n\n  if (backtrackContext.length < subtable.backtrackCoverage.length) return [];\n  var backtrackParams = new ContextParams(backtrackContext, 0);\n  var backtrackLookups = lookupCoverageList(subtable.backtrackCoverage, backtrackParams);\n  var contextRulesMatch = inputLookups.length === subtable.inputCoverage.length && lookaheadLookups.length === subtable.lookaheadCoverage.length && backtrackLookups.length === subtable.backtrackCoverage.length;\n  var substitutions = [];\n\n  if (contextRulesMatch) {\n    for (var i = 0; i < subtable.lookupRecords.length; i++) {\n      var lookupRecord = subtable.lookupRecords[i];\n      var lookupListIndex = lookupRecord.lookupListIndex;\n      var lookupTable = this.getLookupByIndex(lookupListIndex);\n\n      for (var s = 0; s < lookupTable.subtables.length; s++) {\n        var _subtable = lookupTable.subtables[s];\n        var lookup = this.getLookupMethod(lookupTable, _subtable);\n        var substitutionType = this.getSubstitutionType(lookupTable, _subtable);\n\n        if (substitutionType === '12') {\n          for (var n = 0; n < inputLookups.length; n++) {\n            var glyphIndex = contextParams.get(n);\n            var substitution = lookup(glyphIndex);\n            if (substitution) substitutions.push(substitution);\n          }\n        }\n      }\n    }\n  }\n\n  return substitutions;\n}\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\n\n\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n  // COVERAGE LOOKUP //\n  var glyphIndex = contextParams.current;\n  var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n  if (ligSetIndex === -1) return null; // COMPONENTS LOOKUP\n  // (!) note, components are ordered in the written direction.\n\n  var ligature;\n  var ligatureSet = subtable.ligatureSets[ligSetIndex];\n\n  for (var s = 0; s < ligatureSet.length; s++) {\n    ligature = ligatureSet[s];\n\n    for (var l = 0; l < ligature.components.length; l++) {\n      var lookaheadItem = contextParams.lookahead[l];\n      var component = ligature.components[l];\n      if (lookaheadItem !== component) break;\n      if (l === ligature.components.length - 1) return ligature;\n    }\n  }\n\n  return null;\n}\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\n\n\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n  if (substituteIndex === -1) return null;\n  return subtable.sequences[substituteIndex];\n}\n/**\n * Get default script features indexes\n */\n\n\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n  var scripts = this.font.tables.gsub.scripts;\n\n  for (var s = 0; s < scripts.length; s++) {\n    var script = scripts[s];\n    if (script.tag === 'DFLT') return script.script.defaultLangSys.featureIndexes;\n  }\n\n  return [];\n};\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\n\n\nFeatureQuery.prototype.getScriptFeaturesIndexes = function (scriptTag) {\n  var tables = this.font.tables;\n  if (!tables.gsub) return [];\n  if (!scriptTag) return this.getDefaultScriptFeaturesIndexes();\n  var scripts = this.font.tables.gsub.scripts;\n\n  for (var i = 0; i < scripts.length; i++) {\n    var script = scripts[i];\n\n    if (script.tag === scriptTag && script.script.defaultLangSys) {\n      return script.script.defaultLangSys.featureIndexes;\n    } else {\n      var langSysRecords = script.langSysRecords;\n\n      if (!!langSysRecords) {\n        for (var j = 0; j < langSysRecords.length; j++) {\n          var langSysRecord = langSysRecords[j];\n\n          if (langSysRecord.tag === scriptTag) {\n            var langSys = langSysRecord.langSys;\n            return langSys.featureIndexes;\n          }\n        }\n      }\n    }\n  }\n\n  return this.getDefaultScriptFeaturesIndexes();\n};\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\n\n\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n  var tags = {};\n\n  for (var i = 0; i < features.length; i++) {\n    var tag = features[i].tag;\n    var feature = features[i].feature;\n    tags[tag] = feature;\n  }\n\n  this.features[scriptTag].tags = tags;\n};\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\n\n\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n  var features = this.features[scriptTag];\n  if (this.features.hasOwnProperty(scriptTag)) return features;\n  var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n  if (!featuresIndexes) return null;\n  var gsub = this.font.tables.gsub;\n  features = featuresIndexes.map(function (index) {\n    return gsub.features[index];\n  });\n  this.features[scriptTag] = features;\n  this.mapTagsToFeatures(features, scriptTag);\n  return features;\n};\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\n\n\nFeatureQuery.prototype.getSubstitutionType = function (lookupTable, subtable) {\n  var lookupType = lookupTable.lookupType.toString();\n  var substFormat = subtable.substFormat.toString();\n  return lookupType + substFormat;\n};\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\n\n\nFeatureQuery.prototype.getLookupMethod = function (lookupTable, subtable) {\n  var _this = this;\n\n  var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n\n  switch (substitutionType) {\n    case '11':\n      return function (glyphIndex) {\n        return singleSubstitutionFormat1.apply(_this, [glyphIndex, subtable]);\n      };\n\n    case '12':\n      return function (glyphIndex) {\n        return singleSubstitutionFormat2.apply(_this, [glyphIndex, subtable]);\n      };\n\n    case '63':\n      return function (contextParams) {\n        return chainingSubstitutionFormat3.apply(_this, [contextParams, subtable]);\n      };\n\n    case '41':\n      return function (contextParams) {\n        return ligatureSubstitutionFormat1.apply(_this, [contextParams, subtable]);\n      };\n\n    case '21':\n      return function (glyphIndex) {\n        return decompositionSubstitutionFormat1.apply(_this, [glyphIndex, subtable]);\n      };\n\n    default:\n      throw new Error(\"lookupType: \".concat(lookupTable.lookupType, \" - \") + \"substFormat: \".concat(subtable.substFormat, \" \") + \"is not yet supported\");\n  }\n};\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\n\n\nFeatureQuery.prototype.lookupFeature = function (query) {\n  var contextParams = query.contextParams;\n  var currentIndex = contextParams.index;\n  var feature = this.getFeature({\n    tag: query.tag,\n    script: query.script\n  });\n  if (!feature) return new Error(\"font '\".concat(this.font.names.fullName.en, \"' \") + \"doesn't support feature '\".concat(query.tag, \"' \") + \"for script '\".concat(query.script, \"'.\"));\n  var lookups = this.getFeatureLookups(feature);\n  var substitutions = [].concat(contextParams.context);\n\n  for (var l = 0; l < lookups.length; l++) {\n    var lookupTable = lookups[l];\n    var subtables = this.getLookupSubtables(lookupTable);\n\n    for (var s = 0; s < subtables.length; s++) {\n      var subtable = subtables[s];\n      var substType = this.getSubstitutionType(lookupTable, subtable);\n      var lookup = this.getLookupMethod(lookupTable, subtable);\n      var substitution = void 0;\n\n      switch (substType) {\n        case '11':\n          substitution = lookup(contextParams.current);\n\n          if (substitution) {\n            substitutions.splice(currentIndex, 1, new SubstitutionAction({\n              id: 11,\n              tag: query.tag,\n              substitution: substitution\n            }));\n          }\n\n          break;\n\n        case '12':\n          substitution = lookup(contextParams.current);\n\n          if (substitution) {\n            substitutions.splice(currentIndex, 1, new SubstitutionAction({\n              id: 12,\n              tag: query.tag,\n              substitution: substitution\n            }));\n          }\n\n          break;\n\n        case '63':\n          substitution = lookup(contextParams);\n\n          if (Array.isArray(substitution) && substitution.length) {\n            substitutions.splice(currentIndex, 1, new SubstitutionAction({\n              id: 63,\n              tag: query.tag,\n              substitution: substitution\n            }));\n          }\n\n          break;\n\n        case '41':\n          substitution = lookup(contextParams);\n\n          if (substitution) {\n            substitutions.splice(currentIndex, 1, new SubstitutionAction({\n              id: 41,\n              tag: query.tag,\n              substitution: substitution\n            }));\n          }\n\n          break;\n\n        case '21':\n          substitution = lookup(contextParams.current);\n\n          if (substitution) {\n            substitutions.splice(currentIndex, 1, new SubstitutionAction({\n              id: 21,\n              tag: query.tag,\n              substitution: substitution\n            }));\n          }\n\n          break;\n      }\n\n      contextParams = new ContextParams(substitutions, currentIndex);\n      if (Array.isArray(substitution) && !substitution.length) continue;\n      substitution = null;\n    }\n  }\n\n  return substitutions.length ? substitutions : null;\n};\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\n\n\nFeatureQuery.prototype.supports = function (query) {\n  if (!query.script) return false;\n  this.getScriptFeatures(query.script);\n  var supportedScript = this.features.hasOwnProperty(query.script);\n  if (!query.tag) return supportedScript;\n  var supportedFeature = this.features[query.script].some(function (feature) {\n    return feature.tag === query.tag;\n  });\n  return supportedScript && supportedFeature;\n};\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\n\n\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n  return lookupTable.subtables || null;\n};\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\n\n\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n  var lookups = this.font.tables.gsub.lookups;\n  return lookups[index] || null;\n};\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\n\n\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n  // TODO: memoize\n  return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\n\n\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n  if (!this.font) return {\n    FAIL: \"No font was found\"\n  };\n\n  if (!this.features.hasOwnProperty(query.script)) {\n    this.getScriptFeatures(query.script);\n  }\n\n  var scriptFeatures = this.features[query.script];\n  if (!scriptFeatures) return {\n    FAIL: \"No feature for script \".concat(query.script)\n  };\n  if (!scriptFeatures.tags[query.tag]) return null;\n  return this.features[query.script].tags[query.tag];\n};\n\nexport default FeatureQuery;\nexport { FeatureQuery, SubstitutionAction };","map":null,"metadata":{},"sourceType":"module"}