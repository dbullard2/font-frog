{"ast":null,"code":"// The `name` naming table.\n// https://www.microsoft.com/typography/OTSPEC/name.htm\nimport { decode, encode } from '../types';\nimport parse from '../parse';\nimport table from '../table'; // NameIDs for the name table.\n\nvar nameTableNames = ['copyright', // 0\n'fontFamily', // 1\n'fontSubfamily', // 2\n'uniqueID', // 3\n'fullName', // 4\n'version', // 5\n'postScriptName', // 6\n'trademark', // 7\n'manufacturer', // 8\n'designer', // 9\n'description', // 10\n'manufacturerURL', // 11\n'designerURL', // 12\n'license', // 13\n'licenseURL', // 14\n'reserved', // 15\n'preferredFamily', // 16\n'preferredSubfamily', // 17\n'compatibleFullName', // 18\n'sampleText', // 19\n'postScriptFindFontName', // 20\n'wwsFamily', // 21\n'wwsSubfamily' // 22\n];\nvar macLanguages = {\n  0: 'en',\n  1: 'fr',\n  2: 'de',\n  3: 'it',\n  4: 'nl',\n  5: 'sv',\n  6: 'es',\n  7: 'da',\n  8: 'pt',\n  9: 'no',\n  10: 'he',\n  11: 'ja',\n  12: 'ar',\n  13: 'fi',\n  14: 'el',\n  15: 'is',\n  16: 'mt',\n  17: 'tr',\n  18: 'hr',\n  19: 'zh-Hant',\n  20: 'ur',\n  21: 'hi',\n  22: 'th',\n  23: 'ko',\n  24: 'lt',\n  25: 'pl',\n  26: 'hu',\n  27: 'es',\n  28: 'lv',\n  29: 'se',\n  30: 'fo',\n  31: 'fa',\n  32: 'ru',\n  33: 'zh',\n  34: 'nl-BE',\n  35: 'ga',\n  36: 'sq',\n  37: 'ro',\n  38: 'cz',\n  39: 'sk',\n  40: 'si',\n  41: 'yi',\n  42: 'sr',\n  43: 'mk',\n  44: 'bg',\n  45: 'uk',\n  46: 'be',\n  47: 'uz',\n  48: 'kk',\n  49: 'az-Cyrl',\n  50: 'az-Arab',\n  51: 'hy',\n  52: 'ka',\n  53: 'mo',\n  54: 'ky',\n  55: 'tg',\n  56: 'tk',\n  57: 'mn-CN',\n  58: 'mn',\n  59: 'ps',\n  60: 'ks',\n  61: 'ku',\n  62: 'sd',\n  63: 'bo',\n  64: 'ne',\n  65: 'sa',\n  66: 'mr',\n  67: 'bn',\n  68: 'as',\n  69: 'gu',\n  70: 'pa',\n  71: 'or',\n  72: 'ml',\n  73: 'kn',\n  74: 'ta',\n  75: 'te',\n  76: 'si',\n  77: 'my',\n  78: 'km',\n  79: 'lo',\n  80: 'vi',\n  81: 'id',\n  82: 'tl',\n  83: 'ms',\n  84: 'ms-Arab',\n  85: 'am',\n  86: 'ti',\n  87: 'om',\n  88: 'so',\n  89: 'sw',\n  90: 'rw',\n  91: 'rn',\n  92: 'ny',\n  93: 'mg',\n  94: 'eo',\n  128: 'cy',\n  129: 'eu',\n  130: 'ca',\n  131: 'la',\n  132: 'qu',\n  133: 'gn',\n  134: 'ay',\n  135: 'tt',\n  136: 'ug',\n  137: 'dz',\n  138: 'jv',\n  139: 'su',\n  140: 'gl',\n  141: 'af',\n  142: 'br',\n  143: 'iu',\n  144: 'gd',\n  145: 'gv',\n  146: 'ga',\n  147: 'to',\n  148: 'el-polyton',\n  149: 'kl',\n  150: 'az',\n  151: 'nn'\n}; // MacOS language ID → MacOS script ID\n//\n// Note that the script ID is not sufficient to determine what encoding\n// to use in TrueType files. For some languages, MacOS used a modification\n// of a mainstream script. For example, an Icelandic name would be stored\n// with smRoman in the TrueType naming table, but the actual encoding\n// is a special Icelandic version of the normal Macintosh Roman encoding.\n// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n// Syllables but MacOS had run out of available script codes, so this was\n// done as a (pretty radical) \"modification\" of Ethiopic.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\nvar macLanguageToScript = {\n  0: 0,\n  // langEnglish → smRoman\n  1: 0,\n  // langFrench → smRoman\n  2: 0,\n  // langGerman → smRoman\n  3: 0,\n  // langItalian → smRoman\n  4: 0,\n  // langDutch → smRoman\n  5: 0,\n  // langSwedish → smRoman\n  6: 0,\n  // langSpanish → smRoman\n  7: 0,\n  // langDanish → smRoman\n  8: 0,\n  // langPortuguese → smRoman\n  9: 0,\n  // langNorwegian → smRoman\n  10: 5,\n  // langHebrew → smHebrew\n  11: 1,\n  // langJapanese → smJapanese\n  12: 4,\n  // langArabic → smArabic\n  13: 0,\n  // langFinnish → smRoman\n  14: 6,\n  // langGreek → smGreek\n  15: 0,\n  // langIcelandic → smRoman (modified)\n  16: 0,\n  // langMaltese → smRoman\n  17: 0,\n  // langTurkish → smRoman (modified)\n  18: 0,\n  // langCroatian → smRoman (modified)\n  19: 2,\n  // langTradChinese → smTradChinese\n  20: 4,\n  // langUrdu → smArabic\n  21: 9,\n  // langHindi → smDevanagari\n  22: 21,\n  // langThai → smThai\n  23: 3,\n  // langKorean → smKorean\n  24: 29,\n  // langLithuanian → smCentralEuroRoman\n  25: 29,\n  // langPolish → smCentralEuroRoman\n  26: 29,\n  // langHungarian → smCentralEuroRoman\n  27: 29,\n  // langEstonian → smCentralEuroRoman\n  28: 29,\n  // langLatvian → smCentralEuroRoman\n  29: 0,\n  // langSami → smRoman\n  30: 0,\n  // langFaroese → smRoman (modified)\n  31: 4,\n  // langFarsi → smArabic (modified)\n  32: 7,\n  // langRussian → smCyrillic\n  33: 25,\n  // langSimpChinese → smSimpChinese\n  34: 0,\n  // langFlemish → smRoman\n  35: 0,\n  // langIrishGaelic → smRoman (modified)\n  36: 0,\n  // langAlbanian → smRoman\n  37: 0,\n  // langRomanian → smRoman (modified)\n  38: 29,\n  // langCzech → smCentralEuroRoman\n  39: 29,\n  // langSlovak → smCentralEuroRoman\n  40: 0,\n  // langSlovenian → smRoman (modified)\n  41: 5,\n  // langYiddish → smHebrew\n  42: 7,\n  // langSerbian → smCyrillic\n  43: 7,\n  // langMacedonian → smCyrillic\n  44: 7,\n  // langBulgarian → smCyrillic\n  45: 7,\n  // langUkrainian → smCyrillic (modified)\n  46: 7,\n  // langByelorussian → smCyrillic\n  47: 7,\n  // langUzbek → smCyrillic\n  48: 7,\n  // langKazakh → smCyrillic\n  49: 7,\n  // langAzerbaijani → smCyrillic\n  50: 4,\n  // langAzerbaijanAr → smArabic\n  51: 24,\n  // langArmenian → smArmenian\n  52: 23,\n  // langGeorgian → smGeorgian\n  53: 7,\n  // langMoldavian → smCyrillic\n  54: 7,\n  // langKirghiz → smCyrillic\n  55: 7,\n  // langTajiki → smCyrillic\n  56: 7,\n  // langTurkmen → smCyrillic\n  57: 27,\n  // langMongolian → smMongolian\n  58: 7,\n  // langMongolianCyr → smCyrillic\n  59: 4,\n  // langPashto → smArabic\n  60: 4,\n  // langKurdish → smArabic\n  61: 4,\n  // langKashmiri → smArabic\n  62: 4,\n  // langSindhi → smArabic\n  63: 26,\n  // langTibetan → smTibetan\n  64: 9,\n  // langNepali → smDevanagari\n  65: 9,\n  // langSanskrit → smDevanagari\n  66: 9,\n  // langMarathi → smDevanagari\n  67: 13,\n  // langBengali → smBengali\n  68: 13,\n  // langAssamese → smBengali\n  69: 11,\n  // langGujarati → smGujarati\n  70: 10,\n  // langPunjabi → smGurmukhi\n  71: 12,\n  // langOriya → smOriya\n  72: 17,\n  // langMalayalam → smMalayalam\n  73: 16,\n  // langKannada → smKannada\n  74: 14,\n  // langTamil → smTamil\n  75: 15,\n  // langTelugu → smTelugu\n  76: 18,\n  // langSinhalese → smSinhalese\n  77: 19,\n  // langBurmese → smBurmese\n  78: 20,\n  // langKhmer → smKhmer\n  79: 22,\n  // langLao → smLao\n  80: 30,\n  // langVietnamese → smVietnamese\n  81: 0,\n  // langIndonesian → smRoman\n  82: 0,\n  // langTagalog → smRoman\n  83: 0,\n  // langMalayRoman → smRoman\n  84: 4,\n  // langMalayArabic → smArabic\n  85: 28,\n  // langAmharic → smEthiopic\n  86: 28,\n  // langTigrinya → smEthiopic\n  87: 28,\n  // langOromo → smEthiopic\n  88: 0,\n  // langSomali → smRoman\n  89: 0,\n  // langSwahili → smRoman\n  90: 0,\n  // langKinyarwanda → smRoman\n  91: 0,\n  // langRundi → smRoman\n  92: 0,\n  // langNyanja → smRoman\n  93: 0,\n  // langMalagasy → smRoman\n  94: 0,\n  // langEsperanto → smRoman\n  128: 0,\n  // langWelsh → smRoman (modified)\n  129: 0,\n  // langBasque → smRoman\n  130: 0,\n  // langCatalan → smRoman\n  131: 0,\n  // langLatin → smRoman\n  132: 0,\n  // langQuechua → smRoman\n  133: 0,\n  // langGuarani → smRoman\n  134: 0,\n  // langAymara → smRoman\n  135: 7,\n  // langTatar → smCyrillic\n  136: 4,\n  // langUighur → smArabic\n  137: 26,\n  // langDzongkha → smTibetan\n  138: 0,\n  // langJavaneseRom → smRoman\n  139: 0,\n  // langSundaneseRom → smRoman\n  140: 0,\n  // langGalician → smRoman\n  141: 0,\n  // langAfrikaans → smRoman\n  142: 0,\n  // langBreton → smRoman (modified)\n  143: 28,\n  // langInuktitut → smEthiopic (modified)\n  144: 0,\n  // langScottishGaelic → smRoman (modified)\n  145: 0,\n  // langManxGaelic → smRoman (modified)\n  146: 0,\n  // langIrishGaelicScript → smRoman (modified)\n  147: 0,\n  // langTongan → smRoman\n  148: 6,\n  // langGreekAncient → smRoman\n  149: 0,\n  // langGreenlandic → smRoman\n  150: 0,\n  // langAzerbaijanRoman → smRoman\n  151: 0 // langNynorsk → smRoman\n\n}; // While Microsoft indicates a region/country for all its language\n// IDs, we omit the region code if it's equal to the \"most likely\n// region subtag\" according to Unicode CLDR. For scripts, we omit\n// the subtag if it is equal to the Suppress-Script entry in the\n// IANA language subtag registry for IETF BCP 47.\n//\n// For example, Microsoft states that its language code 0x041A is\n// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n// and not 'hr-HR' because Croatia is the default country for Croatian,\n// according to Unicode CLDR. As another example, Microsoft states\n// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n// for the Croatian language, according to IANA.\n//\n// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n\nvar windowsLanguages = {\n  0x0436: 'af',\n  0x041C: 'sq',\n  0x0484: 'gsw',\n  0x045E: 'am',\n  0x1401: 'ar-DZ',\n  0x3C01: 'ar-BH',\n  0x0C01: 'ar',\n  0x0801: 'ar-IQ',\n  0x2C01: 'ar-JO',\n  0x3401: 'ar-KW',\n  0x3001: 'ar-LB',\n  0x1001: 'ar-LY',\n  0x1801: 'ary',\n  0x2001: 'ar-OM',\n  0x4001: 'ar-QA',\n  0x0401: 'ar-SA',\n  0x2801: 'ar-SY',\n  0x1C01: 'aeb',\n  0x3801: 'ar-AE',\n  0x2401: 'ar-YE',\n  0x042B: 'hy',\n  0x044D: 'as',\n  0x082C: 'az-Cyrl',\n  0x042C: 'az',\n  0x046D: 'ba',\n  0x042D: 'eu',\n  0x0423: 'be',\n  0x0845: 'bn',\n  0x0445: 'bn-IN',\n  0x201A: 'bs-Cyrl',\n  0x141A: 'bs',\n  0x047E: 'br',\n  0x0402: 'bg',\n  0x0403: 'ca',\n  0x0C04: 'zh-HK',\n  0x1404: 'zh-MO',\n  0x0804: 'zh',\n  0x1004: 'zh-SG',\n  0x0404: 'zh-TW',\n  0x0483: 'co',\n  0x041A: 'hr',\n  0x101A: 'hr-BA',\n  0x0405: 'cs',\n  0x0406: 'da',\n  0x048C: 'prs',\n  0x0465: 'dv',\n  0x0813: 'nl-BE',\n  0x0413: 'nl',\n  0x0C09: 'en-AU',\n  0x2809: 'en-BZ',\n  0x1009: 'en-CA',\n  0x2409: 'en-029',\n  0x4009: 'en-IN',\n  0x1809: 'en-IE',\n  0x2009: 'en-JM',\n  0x4409: 'en-MY',\n  0x1409: 'en-NZ',\n  0x3409: 'en-PH',\n  0x4809: 'en-SG',\n  0x1C09: 'en-ZA',\n  0x2C09: 'en-TT',\n  0x0809: 'en-GB',\n  0x0409: 'en',\n  0x3009: 'en-ZW',\n  0x0425: 'et',\n  0x0438: 'fo',\n  0x0464: 'fil',\n  0x040B: 'fi',\n  0x080C: 'fr-BE',\n  0x0C0C: 'fr-CA',\n  0x040C: 'fr',\n  0x140C: 'fr-LU',\n  0x180C: 'fr-MC',\n  0x100C: 'fr-CH',\n  0x0462: 'fy',\n  0x0456: 'gl',\n  0x0437: 'ka',\n  0x0C07: 'de-AT',\n  0x0407: 'de',\n  0x1407: 'de-LI',\n  0x1007: 'de-LU',\n  0x0807: 'de-CH',\n  0x0408: 'el',\n  0x046F: 'kl',\n  0x0447: 'gu',\n  0x0468: 'ha',\n  0x040D: 'he',\n  0x0439: 'hi',\n  0x040E: 'hu',\n  0x040F: 'is',\n  0x0470: 'ig',\n  0x0421: 'id',\n  0x045D: 'iu',\n  0x085D: 'iu-Latn',\n  0x083C: 'ga',\n  0x0434: 'xh',\n  0x0435: 'zu',\n  0x0410: 'it',\n  0x0810: 'it-CH',\n  0x0411: 'ja',\n  0x044B: 'kn',\n  0x043F: 'kk',\n  0x0453: 'km',\n  0x0486: 'quc',\n  0x0487: 'rw',\n  0x0441: 'sw',\n  0x0457: 'kok',\n  0x0412: 'ko',\n  0x0440: 'ky',\n  0x0454: 'lo',\n  0x0426: 'lv',\n  0x0427: 'lt',\n  0x082E: 'dsb',\n  0x046E: 'lb',\n  0x042F: 'mk',\n  0x083E: 'ms-BN',\n  0x043E: 'ms',\n  0x044C: 'ml',\n  0x043A: 'mt',\n  0x0481: 'mi',\n  0x047A: 'arn',\n  0x044E: 'mr',\n  0x047C: 'moh',\n  0x0450: 'mn',\n  0x0850: 'mn-CN',\n  0x0461: 'ne',\n  0x0414: 'nb',\n  0x0814: 'nn',\n  0x0482: 'oc',\n  0x0448: 'or',\n  0x0463: 'ps',\n  0x0415: 'pl',\n  0x0416: 'pt',\n  0x0816: 'pt-PT',\n  0x0446: 'pa',\n  0x046B: 'qu-BO',\n  0x086B: 'qu-EC',\n  0x0C6B: 'qu',\n  0x0418: 'ro',\n  0x0417: 'rm',\n  0x0419: 'ru',\n  0x243B: 'smn',\n  0x103B: 'smj-NO',\n  0x143B: 'smj',\n  0x0C3B: 'se-FI',\n  0x043B: 'se',\n  0x083B: 'se-SE',\n  0x203B: 'sms',\n  0x183B: 'sma-NO',\n  0x1C3B: 'sms',\n  0x044F: 'sa',\n  0x1C1A: 'sr-Cyrl-BA',\n  0x0C1A: 'sr',\n  0x181A: 'sr-Latn-BA',\n  0x081A: 'sr-Latn',\n  0x046C: 'nso',\n  0x0432: 'tn',\n  0x045B: 'si',\n  0x041B: 'sk',\n  0x0424: 'sl',\n  0x2C0A: 'es-AR',\n  0x400A: 'es-BO',\n  0x340A: 'es-CL',\n  0x240A: 'es-CO',\n  0x140A: 'es-CR',\n  0x1C0A: 'es-DO',\n  0x300A: 'es-EC',\n  0x440A: 'es-SV',\n  0x100A: 'es-GT',\n  0x480A: 'es-HN',\n  0x080A: 'es-MX',\n  0x4C0A: 'es-NI',\n  0x180A: 'es-PA',\n  0x3C0A: 'es-PY',\n  0x280A: 'es-PE',\n  0x500A: 'es-PR',\n  // Microsoft has defined two different language codes for\n  // “Spanish with modern sorting” and “Spanish with traditional\n  // sorting”. This makes sense for collation APIs, and it would be\n  // possible to express this in BCP 47 language tags via Unicode\n  // extensions (eg., es-u-co-trad is Spanish with traditional\n  // sorting). However, for storing names in fonts, the distinction\n  // does not make sense, so we give “es” in both cases.\n  0x0C0A: 'es',\n  0x040A: 'es',\n  0x540A: 'es-US',\n  0x380A: 'es-UY',\n  0x200A: 'es-VE',\n  0x081D: 'sv-FI',\n  0x041D: 'sv',\n  0x045A: 'syr',\n  0x0428: 'tg',\n  0x085F: 'tzm',\n  0x0449: 'ta',\n  0x0444: 'tt',\n  0x044A: 'te',\n  0x041E: 'th',\n  0x0451: 'bo',\n  0x041F: 'tr',\n  0x0442: 'tk',\n  0x0480: 'ug',\n  0x0422: 'uk',\n  0x042E: 'hsb',\n  0x0420: 'ur',\n  0x0843: 'uz-Cyrl',\n  0x0443: 'uz',\n  0x042A: 'vi',\n  0x0452: 'cy',\n  0x0488: 'wo',\n  0x0485: 'sah',\n  0x0478: 'ii',\n  0x046A: 'yo'\n}; // Returns a IETF BCP 47 language code, for example 'zh-Hant'\n// for 'Chinese in the traditional script'.\n\nfunction getLanguageCode(platformID, languageID, ltag) {\n  switch (platformID) {\n    case 0:\n      // Unicode\n      if (languageID === 0xFFFF) {\n        return 'und';\n      } else if (ltag) {\n        return ltag[languageID];\n      }\n\n      break;\n\n    case 1:\n      // Macintosh\n      return macLanguages[languageID];\n\n    case 3:\n      // Windows\n      return windowsLanguages[languageID];\n  }\n\n  return undefined;\n}\n\nvar utf16 = 'utf-16'; // MacOS script ID → encoding. This table stores the default case,\n// which can be overridden by macLanguageEncodings.\n\nvar macScriptEncodings = {\n  0: 'macintosh',\n  // smRoman\n  1: 'x-mac-japanese',\n  // smJapanese\n  2: 'x-mac-chinesetrad',\n  // smTradChinese\n  3: 'x-mac-korean',\n  // smKorean\n  6: 'x-mac-greek',\n  // smGreek\n  7: 'x-mac-cyrillic',\n  // smCyrillic\n  9: 'x-mac-devanagai',\n  // smDevanagari\n  10: 'x-mac-gurmukhi',\n  // smGurmukhi\n  11: 'x-mac-gujarati',\n  // smGujarati\n  12: 'x-mac-oriya',\n  // smOriya\n  13: 'x-mac-bengali',\n  // smBengali\n  14: 'x-mac-tamil',\n  // smTamil\n  15: 'x-mac-telugu',\n  // smTelugu\n  16: 'x-mac-kannada',\n  // smKannada\n  17: 'x-mac-malayalam',\n  // smMalayalam\n  18: 'x-mac-sinhalese',\n  // smSinhalese\n  19: 'x-mac-burmese',\n  // smBurmese\n  20: 'x-mac-khmer',\n  // smKhmer\n  21: 'x-mac-thai',\n  // smThai\n  22: 'x-mac-lao',\n  // smLao\n  23: 'x-mac-georgian',\n  // smGeorgian\n  24: 'x-mac-armenian',\n  // smArmenian\n  25: 'x-mac-chinesesimp',\n  // smSimpChinese\n  26: 'x-mac-tibetan',\n  // smTibetan\n  27: 'x-mac-mongolian',\n  // smMongolian\n  28: 'x-mac-ethiopic',\n  // smEthiopic\n  29: 'x-mac-ce',\n  // smCentralEuroRoman\n  30: 'x-mac-vietnamese',\n  // smVietnamese\n  31: 'x-mac-extarabic' // smExtArabic\n\n}; // MacOS language ID → encoding. This table stores the exceptional\n// cases, which override macScriptEncodings. For writing MacOS naming\n// tables, we need to emit a MacOS script ID. Therefore, we cannot\n// merge macScriptEncodings into macLanguageEncodings.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\nvar macLanguageEncodings = {\n  15: 'x-mac-icelandic',\n  // langIcelandic\n  17: 'x-mac-turkish',\n  // langTurkish\n  18: 'x-mac-croatian',\n  // langCroatian\n  24: 'x-mac-ce',\n  // langLithuanian\n  25: 'x-mac-ce',\n  // langPolish\n  26: 'x-mac-ce',\n  // langHungarian\n  27: 'x-mac-ce',\n  // langEstonian\n  28: 'x-mac-ce',\n  // langLatvian\n  30: 'x-mac-icelandic',\n  // langFaroese\n  37: 'x-mac-romanian',\n  // langRomanian\n  38: 'x-mac-ce',\n  // langCzech\n  39: 'x-mac-ce',\n  // langSlovak\n  40: 'x-mac-ce',\n  // langSlovenian\n  143: 'x-mac-inuit',\n  // langInuktitut\n  146: 'x-mac-gaelic' // langIrishGaelicScript\n\n};\n\nfunction getEncoding(platformID, encodingID, languageID) {\n  switch (platformID) {\n    case 0:\n      // Unicode\n      return utf16;\n\n    case 1:\n      // Apple Macintosh\n      return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n    case 3:\n      // Microsoft Windows\n      if (encodingID === 1 || encodingID === 10) {\n        return utf16;\n      }\n\n      break;\n  }\n\n  return undefined;\n} // Parse the naming `name` table.\n// FIXME: Format 1 additional fields are not supported yet.\n// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\n\n\nfunction parseNameTable(data, start, ltag) {\n  var name = {};\n  var p = new parse.Parser(data, start);\n  var format = p.parseUShort();\n  var count = p.parseUShort();\n  var stringOffset = p.offset + p.parseUShort();\n\n  for (var i = 0; i < count; i++) {\n    var platformID = p.parseUShort();\n    var encodingID = p.parseUShort();\n    var languageID = p.parseUShort();\n    var nameID = p.parseUShort();\n    var property = nameTableNames[nameID] || nameID;\n    var byteLength = p.parseUShort();\n    var offset = p.parseUShort();\n    var language = getLanguageCode(platformID, languageID, ltag);\n    var encoding = getEncoding(platformID, encodingID, languageID);\n\n    if (encoding !== undefined && language !== undefined) {\n      var text = void 0;\n\n      if (encoding === utf16) {\n        text = decode.UTF16(data, stringOffset + offset, byteLength);\n      } else {\n        text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n      }\n\n      if (text) {\n        var translations = name[property];\n\n        if (translations === undefined) {\n          translations = name[property] = {};\n        }\n\n        translations[language] = text;\n      }\n    }\n  }\n\n  var langTagCount = 0;\n\n  if (format === 1) {\n    // FIXME: Also handle Microsoft's 'name' table 1.\n    langTagCount = p.parseUShort();\n  }\n\n  return name;\n} // {23: 'foo'} → {'foo': 23}\n// ['bar', 'baz'] → {'bar': 0, 'baz': 1}\n\n\nfunction reverseDict(dict) {\n  var result = {};\n\n  for (var key in dict) {\n    result[dict[key]] = parseInt(key);\n  }\n\n  return result;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n  return new table.Record('NameRecord', [{\n    name: 'platformID',\n    type: 'USHORT',\n    value: platformID\n  }, {\n    name: 'encodingID',\n    type: 'USHORT',\n    value: encodingID\n  }, {\n    name: 'languageID',\n    type: 'USHORT',\n    value: languageID\n  }, {\n    name: 'nameID',\n    type: 'USHORT',\n    value: nameID\n  }, {\n    name: 'length',\n    type: 'USHORT',\n    value: length\n  }, {\n    name: 'offset',\n    type: 'USHORT',\n    value: offset\n  }]);\n} // Finds the position of needle in haystack, or -1 if not there.\n// Like String.indexOf(), but for arrays.\n\n\nfunction findSubArray(needle, haystack) {\n  var needleLength = needle.length;\n  var limit = haystack.length - needleLength + 1;\n\n  loop: for (var pos = 0; pos < limit; pos++) {\n    for (; pos < limit; pos++) {\n      for (var k = 0; k < needleLength; k++) {\n        if (haystack[pos + k] !== needle[k]) {\n          continue loop;\n        }\n      }\n\n      return pos;\n    }\n  }\n\n  return -1;\n}\n\nfunction addStringToPool(s, pool) {\n  var offset = findSubArray(s, pool);\n\n  if (offset < 0) {\n    offset = pool.length;\n    var i = 0;\n    var len = s.length;\n\n    for (; i < len; ++i) {\n      pool.push(s[i]);\n    }\n  }\n\n  return offset;\n}\n\nfunction makeNameTable(names, ltag) {\n  var nameID;\n  var nameIDs = [];\n  var namesWithNumericKeys = {};\n  var nameTableIds = reverseDict(nameTableNames);\n\n  for (var key in names) {\n    var id = nameTableIds[key];\n\n    if (id === undefined) {\n      id = key;\n    }\n\n    nameID = parseInt(id);\n\n    if (isNaN(nameID)) {\n      throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n    }\n\n    namesWithNumericKeys[nameID] = names[key];\n    nameIDs.push(nameID);\n  }\n\n  var macLanguageIds = reverseDict(macLanguages);\n  var windowsLanguageIds = reverseDict(windowsLanguages);\n  var nameRecords = [];\n  var stringPool = [];\n\n  for (var i = 0; i < nameIDs.length; i++) {\n    nameID = nameIDs[i];\n    var translations = namesWithNumericKeys[nameID];\n\n    for (var lang in translations) {\n      var text = translations[lang]; // For MacOS, we try to emit the name in the form that was introduced\n      // in the initial version of the TrueType spec (in the late 1980s).\n      // However, this can fail for various reasons: the requested BCP 47\n      // language code might not have an old-style Mac equivalent;\n      // we might not have a codec for the needed character encoding;\n      // or the name might contain characters that cannot be expressed\n      // in the old-style Macintosh encoding. In case of failure, we emit\n      // the name in a more modern fashion (Unicode encoding with BCP 47\n      // language tags) that is recognized by MacOS 10.5, released in 2009.\n      // If fonts were only read by operating systems, we could simply\n      // emit all names in the modern form; this would be much easier.\n      // However, there are many applications and libraries that read\n      // 'name' tables directly, and these will usually only recognize\n      // the ancient form (silently skipping the unrecognized names).\n\n      var macPlatform = 1; // Macintosh\n\n      var macLanguage = macLanguageIds[lang];\n      var macScript = macLanguageToScript[macLanguage];\n      var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n      var macName = encode.MACSTRING(text, macEncoding);\n\n      if (macName === undefined) {\n        macPlatform = 0; // Unicode\n\n        macLanguage = ltag.indexOf(lang);\n\n        if (macLanguage < 0) {\n          macLanguage = ltag.length;\n          ltag.push(lang);\n        }\n\n        macScript = 4; // Unicode 2.0 and later\n\n        macName = encode.UTF16(text);\n      }\n\n      var macNameOffset = addStringToPool(macName, stringPool);\n      nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage, nameID, macName.length, macNameOffset));\n      var winLanguage = windowsLanguageIds[lang];\n\n      if (winLanguage !== undefined) {\n        var winName = encode.UTF16(text);\n        var winNameOffset = addStringToPool(winName, stringPool);\n        nameRecords.push(makeNameRecord(3, 1, winLanguage, nameID, winName.length, winNameOffset));\n      }\n    }\n  }\n\n  nameRecords.sort(function (a, b) {\n    return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;\n  });\n  var t = new table.Table('name', [{\n    name: 'format',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'count',\n    type: 'USHORT',\n    value: nameRecords.length\n  }, {\n    name: 'stringOffset',\n    type: 'USHORT',\n    value: 6 + nameRecords.length * 12\n  }]);\n\n  for (var r = 0; r < nameRecords.length; r++) {\n    t.fields.push({\n      name: 'record_' + r,\n      type: 'RECORD',\n      value: nameRecords[r]\n    });\n  }\n\n  t.fields.push({\n    name: 'strings',\n    type: 'LITERAL',\n    value: stringPool\n  });\n  return t;\n}\n\nexport default {\n  parse: parseNameTable,\n  make: makeNameTable\n};","map":null,"metadata":{},"sourceType":"module"}