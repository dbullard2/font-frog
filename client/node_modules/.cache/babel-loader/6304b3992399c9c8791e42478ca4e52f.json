{"ast":null,"code":"// The `glyf` table describes the glyphs in TrueType outline format.\n// http://www.microsoft.com/typography/otspec/glyf.htm\nimport check from '../check';\nimport glyphset from '../glyphset';\nimport parse from '../parse';\nimport Path from '../path'; // Parse the coordinate data for a glyph.\n\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n  var v;\n\n  if ((flag & shortVectorBitMask) > 0) {\n    // The coordinate is 1 byte long.\n    v = p.parseByte(); // The `same` bit is re-used for short values to signify the sign of the value.\n\n    if ((flag & sameBitMask) === 0) {\n      v = -v;\n    }\n\n    v = previousValue + v;\n  } else {\n    //  The coordinate is 2 bytes long.\n    // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n    if ((flag & sameBitMask) > 0) {\n      v = previousValue;\n    } else {\n      // Parse the coordinate as a signed 16-bit delta value.\n      v = previousValue + p.parseShort();\n    }\n  }\n\n  return v;\n} // Parse a TrueType glyph.\n\n\nfunction parseGlyph(glyph, data, start) {\n  var p = new parse.Parser(data, start);\n  glyph.numberOfContours = p.parseShort();\n  glyph._xMin = p.parseShort();\n  glyph._yMin = p.parseShort();\n  glyph._xMax = p.parseShort();\n  glyph._yMax = p.parseShort();\n  var flags;\n  var flag;\n\n  if (glyph.numberOfContours > 0) {\n    // This glyph is not a composite.\n    var endPointIndices = glyph.endPointIndices = [];\n\n    for (var i = 0; i < glyph.numberOfContours; i += 1) {\n      endPointIndices.push(p.parseUShort());\n    }\n\n    glyph.instructionLength = p.parseUShort();\n    glyph.instructions = [];\n\n    for (var _i = 0; _i < glyph.instructionLength; _i += 1) {\n      glyph.instructions.push(p.parseByte());\n    }\n\n    var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n    flags = [];\n\n    for (var _i2 = 0; _i2 < numberOfCoordinates; _i2 += 1) {\n      flag = p.parseByte();\n      flags.push(flag); // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n\n      if ((flag & 8) > 0) {\n        var repeatCount = p.parseByte();\n\n        for (var j = 0; j < repeatCount; j += 1) {\n          flags.push(flag);\n          _i2 += 1;\n        }\n      }\n    }\n\n    check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n    if (endPointIndices.length > 0) {\n      var points = [];\n      var point; // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n\n      if (numberOfCoordinates > 0) {\n        for (var _i3 = 0; _i3 < numberOfCoordinates; _i3 += 1) {\n          flag = flags[_i3];\n          point = {};\n          point.onCurve = !!(flag & 1);\n          point.lastPointOfContour = endPointIndices.indexOf(_i3) >= 0;\n          points.push(point);\n        }\n\n        var px = 0;\n\n        for (var _i4 = 0; _i4 < numberOfCoordinates; _i4 += 1) {\n          flag = flags[_i4];\n          point = points[_i4];\n          point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n          px = point.x;\n        }\n\n        var py = 0;\n\n        for (var _i5 = 0; _i5 < numberOfCoordinates; _i5 += 1) {\n          flag = flags[_i5];\n          point = points[_i5];\n          point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n          py = point.y;\n        }\n      }\n\n      glyph.points = points;\n    } else {\n      glyph.points = [];\n    }\n  } else if (glyph.numberOfContours === 0) {\n    glyph.points = [];\n  } else {\n    glyph.isComposite = true;\n    glyph.points = [];\n    glyph.components = [];\n    var moreComponents = true;\n\n    while (moreComponents) {\n      flags = p.parseUShort();\n      var component = {\n        glyphIndex: p.parseUShort(),\n        xScale: 1,\n        scale01: 0,\n        scale10: 0,\n        yScale: 1,\n        dx: 0,\n        dy: 0\n      };\n\n      if ((flags & 1) > 0) {\n        // The arguments are words\n        if ((flags & 2) > 0) {\n          // values are offset\n          component.dx = p.parseShort();\n          component.dy = p.parseShort();\n        } else {\n          // values are matched points\n          component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n        }\n      } else {\n        // The arguments are bytes\n        if ((flags & 2) > 0) {\n          // values are offset\n          component.dx = p.parseChar();\n          component.dy = p.parseChar();\n        } else {\n          // values are matched points\n          component.matchedPoints = [p.parseByte(), p.parseByte()];\n        }\n      }\n\n      if ((flags & 8) > 0) {\n        // We have a scale\n        component.xScale = component.yScale = p.parseF2Dot14();\n      } else if ((flags & 64) > 0) {\n        // We have an X / Y scale\n        component.xScale = p.parseF2Dot14();\n        component.yScale = p.parseF2Dot14();\n      } else if ((flags & 128) > 0) {\n        // We have a 2x2 transformation\n        component.xScale = p.parseF2Dot14();\n        component.scale01 = p.parseF2Dot14();\n        component.scale10 = p.parseF2Dot14();\n        component.yScale = p.parseF2Dot14();\n      }\n\n      glyph.components.push(component);\n      moreComponents = !!(flags & 32);\n    }\n\n    if (flags & 0x100) {\n      // We have instructions\n      glyph.instructionLength = p.parseUShort();\n      glyph.instructions = [];\n\n      for (var _i6 = 0; _i6 < glyph.instructionLength; _i6 += 1) {\n        glyph.instructions.push(p.parseByte());\n      }\n    }\n  }\n} // Transform an array of points and return a new array.\n\n\nfunction transformPoints(points, transform) {\n  var newPoints = [];\n\n  for (var i = 0; i < points.length; i += 1) {\n    var pt = points[i];\n    var newPt = {\n      x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n      y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n      onCurve: pt.onCurve,\n      lastPointOfContour: pt.lastPointOfContour\n    };\n    newPoints.push(newPt);\n  }\n\n  return newPoints;\n}\n\nfunction getContours(points) {\n  var contours = [];\n  var currentContour = [];\n\n  for (var i = 0; i < points.length; i += 1) {\n    var pt = points[i];\n    currentContour.push(pt);\n\n    if (pt.lastPointOfContour) {\n      contours.push(currentContour);\n      currentContour = [];\n    }\n  }\n\n  check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n  return contours;\n} // Convert the TrueType glyph outline to a Path.\n\n\nfunction getPath(points) {\n  var p = new Path();\n\n  if (!points) {\n    return p;\n  }\n\n  var contours = getContours(points);\n\n  for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n    var contour = contours[contourIndex];\n    var prev = null;\n    var curr = contour[contour.length - 1];\n    var next = contour[0];\n\n    if (curr.onCurve) {\n      p.moveTo(curr.x, curr.y);\n    } else {\n      if (next.onCurve) {\n        p.moveTo(next.x, next.y);\n      } else {\n        // If both first and last points are off-curve, start at their middle.\n        var start = {\n          x: (curr.x + next.x) * 0.5,\n          y: (curr.y + next.y) * 0.5\n        };\n        p.moveTo(start.x, start.y);\n      }\n    }\n\n    for (var i = 0; i < contour.length; ++i) {\n      prev = curr;\n      curr = next;\n      next = contour[(i + 1) % contour.length];\n\n      if (curr.onCurve) {\n        // This is a straight line.\n        p.lineTo(curr.x, curr.y);\n      } else {\n        var prev2 = prev;\n        var next2 = next;\n\n        if (!prev.onCurve) {\n          prev2 = {\n            x: (curr.x + prev.x) * 0.5,\n            y: (curr.y + prev.y) * 0.5\n          };\n        }\n\n        if (!next.onCurve) {\n          next2 = {\n            x: (curr.x + next.x) * 0.5,\n            y: (curr.y + next.y) * 0.5\n          };\n        }\n\n        p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n      }\n    }\n\n    p.closePath();\n  }\n\n  return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n  if (glyph.isComposite) {\n    for (var j = 0; j < glyph.components.length; j += 1) {\n      var component = glyph.components[j];\n      var componentGlyph = glyphs.get(component.glyphIndex); // Force the ttfGlyphLoader to parse the glyph.\n\n      componentGlyph.getPath();\n\n      if (componentGlyph.points) {\n        var transformedPoints = void 0;\n\n        if (component.matchedPoints === undefined) {\n          // component positioned by offset\n          transformedPoints = transformPoints(componentGlyph.points, component);\n        } else {\n          // component positioned by matched points\n          if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {\n            throw Error('Matched points out of range in ' + glyph.name);\n          }\n\n          var firstPt = glyph.points[component.matchedPoints[0]];\n          var secondPt = componentGlyph.points[component.matchedPoints[1]];\n          var transform = {\n            xScale: component.xScale,\n            scale01: component.scale01,\n            scale10: component.scale10,\n            yScale: component.yScale,\n            dx: 0,\n            dy: 0\n          };\n          secondPt = transformPoints([secondPt], transform)[0];\n          transform.dx = firstPt.x - secondPt.x;\n          transform.dy = firstPt.y - secondPt.y;\n          transformedPoints = transformPoints(componentGlyph.points, transform);\n        }\n\n        glyph.points = glyph.points.concat(transformedPoints);\n      }\n    }\n  }\n\n  return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n  var glyphs = new glyphset.GlyphSet(font); // The last element of the loca table is invalid.\n\n  for (var i = 0; i < loca.length - 1; i += 1) {\n    var offset = loca[i];\n    var nextOffset = loca[i + 1];\n\n    if (offset !== nextOffset) {\n      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n    } else {\n      glyphs.push(i, glyphset.glyphLoader(font, i));\n    }\n  }\n\n  return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n  var glyphs = new glyphset.GlyphSet(font);\n\n  font._push = function (i) {\n    var offset = loca[i];\n    var nextOffset = loca[i + 1];\n\n    if (offset !== nextOffset) {\n      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n    } else {\n      glyphs.push(i, glyphset.glyphLoader(font, i));\n    }\n  };\n\n  return glyphs;\n} // Parse all the glyphs according to the offsets from the `loca` table.\n\n\nfunction parseGlyfTable(data, start, loca, font, opt) {\n  if (opt.lowMemory) return parseGlyfTableOnLowMemory(data, start, loca, font);else return parseGlyfTableAll(data, start, loca, font);\n}\n\nexport default {\n  getPath: getPath,\n  parse: parseGlyfTable\n};","map":null,"metadata":{},"sourceType":"module"}