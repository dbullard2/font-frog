{"ast":null,"code":"// The Font object\nimport Path from './path';\nimport sfnt from './tables/sfnt';\nimport { DefaultEncoding } from './encoding';\nimport glyphset from './glyphset';\nimport Position from './position';\nimport Substitution from './substitution';\nimport { isBrowser, checkArgument, arrayBufferToNodeBuffer } from './util';\nimport HintingTrueType from './hintingtt';\nimport Bidi from './bidi';\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\n\nfunction Font(options) {\n  options = options || {};\n\n  if (!options.empty) {\n    // Check that we've provided the minimum set of names.\n    checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n    checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n    checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n    checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n    checkArgument(options.descender, 'When creating a new Font object, descender is required.');\n    checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).'); // OS X will complain if the names are empty, so we put a single space everywhere by default.\n\n    this.names = {\n      fontFamily: {\n        en: options.familyName || ' '\n      },\n      fontSubfamily: {\n        en: options.styleName || ' '\n      },\n      fullName: {\n        en: options.fullName || options.familyName + ' ' + options.styleName\n      },\n      // postScriptName may not contain any whitespace\n      postScriptName: {\n        en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')\n      },\n      designer: {\n        en: options.designer || ' '\n      },\n      designerURL: {\n        en: options.designerURL || ' '\n      },\n      manufacturer: {\n        en: options.manufacturer || ' '\n      },\n      manufacturerURL: {\n        en: options.manufacturerURL || ' '\n      },\n      license: {\n        en: options.license || ' '\n      },\n      licenseURL: {\n        en: options.licenseURL || ' '\n      },\n      version: {\n        en: options.version || 'Version 0.1'\n      },\n      description: {\n        en: options.description || ' '\n      },\n      copyright: {\n        en: options.copyright || ' '\n      },\n      trademark: {\n        en: options.trademark || ' '\n      }\n    };\n    this.unitsPerEm = options.unitsPerEm || 1000;\n    this.ascender = options.ascender;\n    this.descender = options.descender;\n    this.createdTimestamp = options.createdTimestamp;\n    this.tables = {\n      os2: {\n        usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n        usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n        fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR\n      }\n    };\n  }\n\n  this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n\n  this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n  this.encoding = new DefaultEncoding(this);\n  this.position = new Position(this);\n  this.substitution = new Substitution(this);\n  this.tables = this.tables || {}; // needed for low memory mode only.\n\n  this._push = null;\n  this._hmtxTableData = {};\n  Object.defineProperty(this, 'hinting', {\n    get: function get() {\n      if (this._hinting) return this._hinting;\n\n      if (this.outlinesFormat === 'truetype') {\n        return this._hinting = new HintingTrueType(this);\n      }\n    }\n  });\n}\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\n\n\nFont.prototype.hasChar = function (c) {\n  return this.encoding.charToGlyphIndex(c) !== null;\n};\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\n\n\nFont.prototype.charToGlyphIndex = function (s) {\n  return this.encoding.charToGlyphIndex(s);\n};\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\n\n\nFont.prototype.charToGlyph = function (c) {\n  var glyphIndex = this.charToGlyphIndex(c);\n  var glyph = this.glyphs.get(glyphIndex);\n\n  if (!glyph) {\n    // .notdef\n    glyph = this.glyphs.get(0);\n  }\n\n  return glyph;\n};\n/**\n * Update features\n * @param {any} options features options\n */\n\n\nFont.prototype.updateFeatures = function (options) {\n  // TODO: update all features options not only 'latn'.\n  return this.defaultRenderOptions.features.map(function (feature) {\n    if (feature.script === 'latn') {\n      return {\n        script: 'latn',\n        tags: feature.tags.filter(function (tag) {\n          return options[tag];\n        })\n      };\n    } else {\n      return feature;\n    }\n  });\n};\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\n\n\nFont.prototype.stringToGlyphs = function (s, options) {\n  var _this2 = this;\n\n  var bidi = new Bidi(); // Create and register 'glyphIndex' state modifier\n\n  var charToGlyphIndexMod = function charToGlyphIndexMod(token) {\n    return _this2.charToGlyphIndex(token.char);\n  };\n\n  bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod); // roll-back to default features\n\n  var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features;\n  bidi.applyFeatures(this, features);\n  var indexes = bidi.getTextGlyphs(s);\n  var length = indexes.length; // convert glyph indexes to glyph objects\n\n  var glyphs = new Array(length);\n  var notdef = this.glyphs.get(0);\n\n  for (var i = 0; i < length; i += 1) {\n    glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n  }\n\n  return glyphs;\n};\n/**\n * @param  {string}\n * @return {Number}\n */\n\n\nFont.prototype.nameToGlyphIndex = function (name) {\n  return this.glyphNames.nameToGlyphIndex(name);\n};\n/**\n * @param  {string}\n * @return {opentype.Glyph}\n */\n\n\nFont.prototype.nameToGlyph = function (name) {\n  var glyphIndex = this.nameToGlyphIndex(name);\n  var glyph = this.glyphs.get(glyphIndex);\n\n  if (!glyph) {\n    // .notdef\n    glyph = this.glyphs.get(0);\n  }\n\n  return glyph;\n};\n/**\n * @param  {Number}\n * @return {String}\n */\n\n\nFont.prototype.glyphIndexToName = function (gid) {\n  if (!this.glyphNames.glyphIndexToName) {\n    return '';\n  }\n\n  return this.glyphNames.glyphIndexToName(gid);\n};\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\n\n\nFont.prototype.getKerningValue = function (leftGlyph, rightGlyph) {\n  leftGlyph = leftGlyph.index || leftGlyph;\n  rightGlyph = rightGlyph.index || rightGlyph;\n  var gposKerning = this.position.defaultKerningTables;\n\n  if (gposKerning) {\n    return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n  } // \"kern\" table\n\n\n  return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\n\n\nFont.prototype.defaultRenderOptions = {\n  kerning: true,\n  features: [\n  /**\n   * these 4 features are required to render Arabic text properly\n   * and shouldn't be turned off when rendering arabic text.\n   */\n  {\n    script: 'arab',\n    tags: ['init', 'medi', 'fina', 'rlig']\n  }, {\n    script: 'latn',\n    tags: ['liga', 'rlig']\n  }]\n};\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\n\nFont.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {\n  x = x !== undefined ? x : 0;\n  y = y !== undefined ? y : 0;\n  fontSize = fontSize !== undefined ? fontSize : 72;\n  options = options || this.defaultRenderOptions;\n  var fontScale = 1 / this.unitsPerEm * fontSize;\n  var glyphs = this.stringToGlyphs(text, options);\n  var kerningLookups;\n\n  if (options.kerning) {\n    var script = options.script || this.position.getDefaultScriptName();\n    kerningLookups = this.position.getKerningTables(script, options.language);\n  }\n\n  for (var i = 0; i < glyphs.length; i += 1) {\n    var glyph = glyphs[i];\n    callback.call(this, glyph, x, y, fontSize, options);\n\n    if (glyph.advanceWidth) {\n      x += glyph.advanceWidth * fontScale;\n    }\n\n    if (options.kerning && i < glyphs.length - 1) {\n      // We should apply position adjustment lookups in a more generic way.\n      // Here we only use the xAdvance value.\n      var kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) : this.getKerningValue(glyph, glyphs[i + 1]);\n      x += kerningValue * fontScale;\n    }\n\n    if (options.letterSpacing) {\n      x += options.letterSpacing * fontSize;\n    } else if (options.tracking) {\n      x += options.tracking / 1000 * fontSize;\n    }\n  }\n\n  return x;\n};\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\n\n\nFont.prototype.getPath = function (text, x, y, fontSize, options) {\n  var fullPath = new Path();\n  this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n    fullPath.extend(glyphPath);\n  });\n  return fullPath;\n};\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\n\n\nFont.prototype.getPaths = function (text, x, y, fontSize, options) {\n  var glyphPaths = [];\n  this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n    glyphPaths.push(glyphPath);\n  });\n  return glyphPaths;\n};\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\n\n\nFont.prototype.getAdvanceWidth = function (text, fontSize, options) {\n  return this.forEachGlyph(text, 0, 0, fontSize, options, function () {});\n};\n/**\n * Draw the text on the given drawing context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n */\n\n\nFont.prototype.draw = function (ctx, text, x, y, fontSize, options) {\n  this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n/**\n * Draw the points of all glyphs in the text.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\n\n\nFont.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {\n  this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n    glyph.drawPoints(ctx, gX, gY, gFontSize);\n  });\n};\n/**\n * Draw lines indicating important font measurements for all glyphs in the text.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\n\n\nFont.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {\n  this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n    glyph.drawMetrics(ctx, gX, gY, gFontSize);\n  });\n};\n/**\n * @param  {string}\n * @return {string}\n */\n\n\nFont.prototype.getEnglishName = function (name) {\n  var translations = this.names[name];\n\n  if (translations) {\n    return translations.en;\n  }\n};\n/**\n * Validate\n */\n\n\nFont.prototype.validate = function () {\n  var warnings = [];\n\n  var _this = this;\n\n  function assert(predicate, message) {\n    if (!predicate) {\n      warnings.push(message);\n    }\n  }\n\n  function assertNamePresent(name) {\n    var englishName = _this.getEnglishName(name);\n\n    assert(englishName && englishName.trim().length > 0, 'No English ' + name + ' specified.');\n  } // Identification information\n\n\n  assertNamePresent('fontFamily');\n  assertNamePresent('weightName');\n  assertNamePresent('manufacturer');\n  assertNamePresent('copyright');\n  assertNamePresent('version'); // Dimension information\n\n  assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');\n};\n/**\n * Convert the font object to a SFNT data structure.\n * This structure contains all the necessary tables and metadata to create a binary OTF file.\n * @return {opentype.Table}\n */\n\n\nFont.prototype.toTables = function () {\n  return sfnt.fontToTable(this);\n};\n/**\n * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n */\n\n\nFont.prototype.toBuffer = function () {\n  console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n  return this.toArrayBuffer();\n};\n/**\n * Converts a `opentype.Font` into an `ArrayBuffer`\n * @return {ArrayBuffer}\n */\n\n\nFont.prototype.toArrayBuffer = function () {\n  var sfntTable = this.toTables();\n  var bytes = sfntTable.encode();\n  var buffer = new ArrayBuffer(bytes.length);\n  var intArray = new Uint8Array(buffer);\n\n  for (var i = 0; i < bytes.length; i++) {\n    intArray[i] = bytes[i];\n  }\n\n  return buffer;\n};\n/**\n * Initiate a download of the OpenType font.\n */\n\n\nFont.prototype.download = function (fileName) {\n  var familyName = this.getEnglishName('fontFamily');\n  var styleName = this.getEnglishName('fontSubfamily');\n  fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n  var arrayBuffer = this.toArrayBuffer();\n\n  if (isBrowser()) {\n    window.URL = window.URL || window.webkitURL;\n\n    if (window.URL) {\n      var dataView = new DataView(arrayBuffer);\n      var blob = new Blob([dataView], {\n        type: 'font/opentype'\n      });\n      var link = document.createElement('a');\n      link.href = window.URL.createObjectURL(blob);\n      link.download = fileName;\n      var event = document.createEvent('MouseEvents');\n      event.initEvent('click', true, false);\n      link.dispatchEvent(event);\n    } else {\n      console.warn('Font file could not be downloaded. Try using a different browser.');\n    }\n  } else {\n    var fs = require('fs');\n\n    var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n    fs.writeFileSync(fileName, buffer);\n  }\n};\n/**\n * @private\n */\n\n\nFont.prototype.fsSelectionValues = {\n  ITALIC: 0x001,\n  //1\n  UNDERSCORE: 0x002,\n  //2\n  NEGATIVE: 0x004,\n  //4\n  OUTLINED: 0x008,\n  //8\n  STRIKEOUT: 0x010,\n  //16\n  BOLD: 0x020,\n  //32\n  REGULAR: 0x040,\n  //64\n  USER_TYPO_METRICS: 0x080,\n  //128\n  WWS: 0x100,\n  //256\n  OBLIQUE: 0x200 //512\n\n};\n/**\n * @private\n */\n\nFont.prototype.usWidthClasses = {\n  ULTRA_CONDENSED: 1,\n  EXTRA_CONDENSED: 2,\n  CONDENSED: 3,\n  SEMI_CONDENSED: 4,\n  MEDIUM: 5,\n  SEMI_EXPANDED: 6,\n  EXPANDED: 7,\n  EXTRA_EXPANDED: 8,\n  ULTRA_EXPANDED: 9\n};\n/**\n * @private\n */\n\nFont.prototype.usWeightClasses = {\n  THIN: 100,\n  EXTRA_LIGHT: 200,\n  LIGHT: 300,\n  NORMAL: 400,\n  MEDIUM: 500,\n  SEMI_BOLD: 600,\n  BOLD: 700,\n  EXTRA_BOLD: 800,\n  BLACK: 900\n};\nexport default Font;","map":null,"metadata":{},"sourceType":"module"}