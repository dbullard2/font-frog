{"ast":null,"code":"/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n'use strict';\n\nimport glyf from './tables/glyf';\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\n\nfunction Hinting(font) {\n  // the font this hinting object is for\n  this.font = font;\n\n  this.getCommands = function (hPoints) {\n    return glyf.getPath(hPoints).commands;\n  }; // cached states\n\n\n  this._fpgmState = this._prepState = undefined; // errorState\n  // 0 ... all okay\n  // 1 ... had an error in a glyf,\n  //       continue working but stop spamming\n  //       the console\n  // 2 ... error at prep, stop hinting at this ppem\n  // 3 ... error at fpeg, stop hinting for this font at all\n\n  this._errorState = 0;\n}\n/*\n* Not rounding.\n*/\n\n\nfunction roundOff(v) {\n  return v;\n}\n/*\n* Rounding to grid.\n*/\n\n\nfunction roundToGrid(v) {\n  //Rounding in TT is supposed to \"symmetrical around zero\"\n  return Math.sign(v) * Math.round(Math.abs(v));\n}\n/*\n* Rounding to double grid.\n*/\n\n\nfunction roundToDoubleGrid(v) {\n  return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n/*\n* Rounding to half grid.\n*/\n\n\nfunction roundToHalfGrid(v) {\n  return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n/*\n* Rounding to up to grid.\n*/\n\n\nfunction roundUpToGrid(v) {\n  return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n/*\n* Rounding to down to grid.\n*/\n\n\nfunction roundDownToGrid(v) {\n  return Math.sign(v) * Math.floor(Math.abs(v));\n}\n/*\n* Super rounding.\n*/\n\n\nvar roundSuper = function roundSuper(v) {\n  var period = this.srPeriod;\n  var phase = this.srPhase;\n  var threshold = this.srThreshold;\n  var sign = 1;\n\n  if (v < 0) {\n    v = -v;\n    sign = -1;\n  }\n\n  v += threshold - phase;\n  v = Math.trunc(v / period) * period;\n  v += phase; // according to http://xgridfit.sourceforge.net/round.html\n\n  if (v < 0) return phase * sign;\n  return v * sign;\n};\n/*\n* Unit vector of x-axis.\n*/\n\n\nvar xUnitVector = {\n  x: 1,\n  y: 0,\n  axis: 'x',\n  // Gets the projected distance between two points.\n  // o1/o2 ... if true, respective original position is used.\n  distance: function distance(p1, p2, o1, o2) {\n    return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n  },\n  // Moves point p so the moved position has the same relative\n  // position to the moved positions of rp1 and rp2 than the\n  // original positions had.\n  //\n  // See APPENDIX on INTERPOLATE at the bottom of this file.\n  interpolate: function interpolate(p, rp1, rp2, pv) {\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dm1;\n    var dm2;\n    var dt;\n\n    if (!pv || pv === this) {\n      do1 = p.xo - rp1.xo;\n      do2 = p.xo - rp2.xo;\n      dm1 = rp1.x - rp1.xo;\n      dm2 = rp2.x - rp2.xo;\n      doa1 = Math.abs(do1);\n      doa2 = Math.abs(do2);\n      dt = doa1 + doa2;\n\n      if (dt === 0) {\n        p.x = p.xo + (dm1 + dm2) / 2;\n        return;\n      }\n\n      p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n      return;\n    }\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n      xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n      return;\n    }\n\n    xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n  },\n  // Slope of line normal to this\n  normalSlope: Number.NEGATIVE_INFINITY,\n  // Sets the point 'p' relative to point 'rp'\n  // by the distance 'd'.\n  //\n  // See APPENDIX on SETRELATIVE at the bottom of this file.\n  //\n  // p   ... point to set\n  // rp  ... reference point\n  // d   ... distance on projection vector\n  // pv  ... projection vector (undefined = this)\n  // org ... if true, uses the original position of rp as reference.\n  setRelative: function setRelative(p, rp, d, pv, org) {\n    if (!pv || pv === this) {\n      p.x = (org ? rp.xo : rp.x) + d;\n      return;\n    }\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n    p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n  },\n  // Slope of vector line.\n  slope: 0,\n  // Touches the point p.\n  touch: function touch(p) {\n    p.xTouched = true;\n  },\n  // Tests if a point p is touched.\n  touched: function touched(p) {\n    return p.xTouched;\n  },\n  // Untouches the point p.\n  untouch: function untouch(p) {\n    p.xTouched = false;\n  }\n};\n/*\n* Unit vector of y-axis.\n*/\n\nvar yUnitVector = {\n  x: 0,\n  y: 1,\n  axis: 'y',\n  // Gets the projected distance between two points.\n  // o1/o2 ... if true, respective original position is used.\n  distance: function distance(p1, p2, o1, o2) {\n    return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n  },\n  // Moves point p so the moved position has the same relative\n  // position to the moved positions of rp1 and rp2 than the\n  // original positions had.\n  //\n  // See APPENDIX on INTERPOLATE at the bottom of this file.\n  interpolate: function interpolate(p, rp1, rp2, pv) {\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dm1;\n    var dm2;\n    var dt;\n\n    if (!pv || pv === this) {\n      do1 = p.yo - rp1.yo;\n      do2 = p.yo - rp2.yo;\n      dm1 = rp1.y - rp1.yo;\n      dm2 = rp2.y - rp2.yo;\n      doa1 = Math.abs(do1);\n      doa2 = Math.abs(do2);\n      dt = doa1 + doa2;\n\n      if (dt === 0) {\n        p.y = p.yo + (dm1 + dm2) / 2;\n        return;\n      }\n\n      p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n      return;\n    }\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n      yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n      return;\n    }\n\n    yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n  },\n  // Slope of line normal to this.\n  normalSlope: 0,\n  // Sets the point 'p' relative to point 'rp'\n  // by the distance 'd'\n  //\n  // See APPENDIX on SETRELATIVE at the bottom of this file.\n  //\n  // p   ... point to set\n  // rp  ... reference point\n  // d   ... distance on projection vector\n  // pv  ... projection vector (undefined = this)\n  // org ... if true, uses the original position of rp as reference.\n  setRelative: function setRelative(p, rp, d, pv, org) {\n    if (!pv || pv === this) {\n      p.y = (org ? rp.yo : rp.y) + d;\n      return;\n    }\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n    p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n  },\n  // Slope of vector line.\n  slope: Number.POSITIVE_INFINITY,\n  // Touches the point p.\n  touch: function touch(p) {\n    p.yTouched = true;\n  },\n  // Tests if a point p is touched.\n  touched: function touched(p) {\n    return p.yTouched;\n  },\n  // Untouches the point p.\n  untouch: function untouch(p) {\n    p.yTouched = false;\n  }\n};\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\n\nfunction UnitVector(x, y) {\n  this.x = x;\n  this.y = y;\n  this.axis = undefined;\n  this.slope = y / x;\n  this.normalSlope = -x / y;\n  Object.freeze(this);\n}\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\n\n\nUnitVector.prototype.distance = function (p1, p2, o1, o2) {\n  return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);\n};\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\n\n\nUnitVector.prototype.interpolate = function (p, rp1, rp2, pv) {\n  var dm1;\n  var dm2;\n  var do1;\n  var do2;\n  var doa1;\n  var doa2;\n  var dt;\n  do1 = pv.distance(p, rp1, true, true);\n  do2 = pv.distance(p, rp2, true, true);\n  dm1 = pv.distance(rp1, rp1, false, true);\n  dm2 = pv.distance(rp2, rp2, false, true);\n  doa1 = Math.abs(do1);\n  doa2 = Math.abs(do2);\n  dt = doa1 + doa2;\n\n  if (dt === 0) {\n    this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n    return;\n  }\n\n  this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\n\n\nUnitVector.prototype.setRelative = function (p, rp, d, pv, org) {\n  pv = pv || this;\n  var rpx = org ? rp.xo : rp.x;\n  var rpy = org ? rp.yo : rp.y;\n  var rpdx = rpx + d * pv.x;\n  var rpdy = rpy + d * pv.y;\n  var pvns = pv.normalSlope;\n  var fvs = this.slope;\n  var px = p.x;\n  var py = p.y;\n  p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n  p.y = fvs * (p.x - px) + py;\n};\n/*\n* Touches the point p.\n*/\n\n\nUnitVector.prototype.touch = function (p) {\n  p.xTouched = true;\n  p.yTouched = true;\n};\n/*\n* Returns a unit vector with x/y coordinates.\n*/\n\n\nfunction getUnitVector(x, y) {\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d;\n  if (x === 1 && y === 0) return xUnitVector;else if (x === 0 && y === 1) return yUnitVector;else return new UnitVector(x, y);\n}\n/*\n* Creates a point in the hinting engine.\n*/\n\n\nfunction HPoint(x, y, lastPointOfContour, onCurve) {\n  this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n\n  this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n  this.lastPointOfContour = lastPointOfContour;\n  this.onCurve = onCurve;\n  this.prevPointOnContour = undefined;\n  this.nextPointOnContour = undefined;\n  this.xTouched = false;\n  this.yTouched = false;\n  Object.preventExtensions(this);\n}\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\n\n\nHPoint.prototype.nextTouched = function (v) {\n  var p = this.nextPointOnContour;\n\n  while (!v.touched(p) && p !== this) {\n    p = p.nextPointOnContour;\n  }\n\n  return p;\n};\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\n\n\nHPoint.prototype.prevTouched = function (v) {\n  var p = this.prevPointOnContour;\n\n  while (!v.touched(p) && p !== this) {\n    p = p.prevPointOnContour;\n  }\n\n  return p;\n};\n/*\n* The zero point.\n*/\n\n\nvar HPZero = Object.freeze(new HPoint(0, 0));\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\n\nvar defaultState = {\n  cvCutIn: 17 / 16,\n  // control value cut in\n  deltaBase: 9,\n  deltaShift: 0.125,\n  loop: 1,\n  // loops some instructions\n  minDis: 1,\n  // minimum distance\n  autoFlip: true\n};\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\n\nfunction State(env, prog) {\n  this.env = env;\n  this.stack = [];\n  this.prog = prog;\n\n  switch (env) {\n    case 'glyf':\n      this.zp0 = this.zp1 = this.zp2 = 1;\n      this.rp0 = this.rp1 = this.rp2 = 0;\n\n    /* fall through */\n\n    case 'prep':\n      this.fv = this.pv = this.dpv = xUnitVector;\n      this.round = roundToGrid;\n  }\n}\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\n\n\nHinting.prototype.exec = function (glyph, ppem) {\n  if (typeof ppem !== 'number') {\n    throw new Error('Point size is not a number!');\n  } // Received a fatal error, don't do any hinting anymore.\n\n\n  if (this._errorState > 2) return;\n  var font = this.font;\n  var prepState = this._prepState;\n\n  if (!prepState || prepState.ppem !== ppem) {\n    var fpgmState = this._fpgmState;\n\n    if (!fpgmState) {\n      // Executes the fpgm state.\n      // This is used by fonts to define functions.\n      State.prototype = defaultState;\n      fpgmState = this._fpgmState = new State('fpgm', font.tables.fpgm);\n      fpgmState.funcs = [];\n      fpgmState.font = font;\n\n      if (exports.DEBUG) {\n        console.log('---EXEC FPGM---');\n        fpgmState.step = -1;\n      }\n\n      try {\n        exec(fpgmState);\n      } catch (e) {\n        console.log('Hinting error in FPGM:' + e);\n        this._errorState = 3;\n        return;\n      }\n    } // Executes the prep program for this ppem setting.\n    // This is used by fonts to set cvt values\n    // depending on to be rendered font size.\n\n\n    State.prototype = fpgmState;\n    prepState = this._prepState = new State('prep', font.tables.prep);\n    prepState.ppem = ppem; // Creates a copy of the cvt table\n    // and scales it to the current ppem setting.\n\n    var oCvt = font.tables.cvt;\n\n    if (oCvt) {\n      var cvt = prepState.cvt = new Array(oCvt.length);\n      var scale = ppem / font.unitsPerEm;\n\n      for (var c = 0; c < oCvt.length; c++) {\n        cvt[c] = oCvt[c] * scale;\n      }\n    } else {\n      prepState.cvt = [];\n    }\n\n    if (exports.DEBUG) {\n      console.log('---EXEC PREP---');\n      prepState.step = -1;\n    }\n\n    try {\n      exec(prepState);\n    } catch (e) {\n      if (this._errorState < 2) {\n        console.log('Hinting error in PREP:' + e);\n      }\n\n      this._errorState = 2;\n    }\n  }\n\n  if (this._errorState > 1) return;\n\n  try {\n    return execGlyph(glyph, prepState);\n  } catch (e) {\n    if (this._errorState < 1) {\n      console.log('Hinting error:' + e);\n      console.log('Note: further hinting errors are silenced');\n    }\n\n    this._errorState = 1;\n    return undefined;\n  }\n};\n/*\n* Executes the hinting program for a glyph.\n*/\n\n\nexecGlyph = function execGlyph(glyph, prepState) {\n  // original point positions\n  var xScale = prepState.ppem / prepState.font.unitsPerEm;\n  var yScale = xScale;\n  var components = glyph.components;\n  var contours;\n  var gZone;\n  var state;\n  State.prototype = prepState;\n\n  if (!components) {\n    state = new State('glyf', glyph.instructions);\n\n    if (exports.DEBUG) {\n      console.log('---EXEC GLYPH---');\n      state.step = -1;\n    }\n\n    execComponent(glyph, state, xScale, yScale);\n    gZone = state.gZone;\n  } else {\n    var font = prepState.font;\n    gZone = [];\n    contours = [];\n\n    for (var i = 0; i < components.length; i++) {\n      var c = components[i];\n      var cg = font.glyphs.get(c.glyphIndex);\n      state = new State('glyf', cg.instructions);\n\n      if (exports.DEBUG) {\n        console.log('---EXEC COMP ' + i + '---');\n        state.step = -1;\n      }\n\n      execComponent(cg, state, xScale, yScale); // appends the computed points to the result array\n      // post processes the component points\n\n      var dx = Math.round(c.dx * xScale);\n      var dy = Math.round(c.dy * yScale);\n      var gz = state.gZone;\n      var cc = state.contours;\n\n      for (var pi = 0; pi < gz.length; pi++) {\n        var p = gz[pi];\n        p.xTouched = p.yTouched = false;\n        p.xo = p.x = p.x + dx;\n        p.yo = p.y = p.y + dy;\n      }\n\n      var gLen = gZone.length;\n      gZone.push.apply(gZone, gz);\n\n      for (var j = 0; j < cc.length; j++) {\n        contours.push(cc[j] + gLen);\n      }\n    }\n\n    if (glyph.instructions && !state.inhibitGridFit) {\n      // the composite has instructions on its own\n      state = new State('glyf', glyph.instructions);\n      state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n      state.contours = contours; // note: HPZero cannot be used here, since\n      //       the point might be modified\n\n      gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));\n\n      if (exports.DEBUG) {\n        console.log('---EXEC COMPOSITE---');\n        state.step = -1;\n      }\n\n      exec(state);\n      gZone.length -= 2;\n    }\n  }\n\n  return gZone;\n};\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\n\n\nexecComponent = function execComponent(glyph, state, xScale, yScale) {\n  var points = glyph.points || [];\n  var pLen = points.length;\n  var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n  var contours = state.contours = []; // Scales the original points and\n  // makes copies for the hinted points.\n\n  var cp; // current point\n\n  for (var i = 0; i < pLen; i++) {\n    cp = points[i];\n    gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve);\n  } // Chain links the contours.\n\n\n  var sp; // start point\n\n  var np; // next point\n\n  for (var _i = 0; _i < pLen; _i++) {\n    cp = gZone[_i];\n\n    if (!sp) {\n      sp = cp;\n      contours.push(_i);\n    }\n\n    if (cp.lastPointOfContour) {\n      cp.nextPointOnContour = sp;\n      sp.prevPointOnContour = cp;\n      sp = undefined;\n    } else {\n      np = gZone[_i + 1];\n      cp.nextPointOnContour = np;\n      np.prevPointOnContour = cp;\n    }\n  }\n\n  if (state.inhibitGridFit) return;\n\n  if (exports.DEBUG) {\n    console.log('PROCESSING GLYPH', state.stack);\n\n    for (var _i2 = 0; _i2 < pLen; _i2++) {\n      console.log(_i2, gZone[_i2].x, gZone[_i2].y);\n    }\n  }\n\n  gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));\n  exec(state); // Removes the extra points.\n\n  gZone.length -= 2;\n\n  if (exports.DEBUG) {\n    console.log('FINISHED GLYPH', state.stack);\n\n    for (var _i3 = 0; _i3 < pLen; _i3++) {\n      console.log(_i3, gZone[_i3].x, gZone[_i3].y);\n    }\n  }\n};\n/*\n* Executes the program loaded in state.\n*/\n\n\nexec = function exec(state) {\n  var prog = state.prog;\n  if (!prog) return;\n  var pLen = prog.length;\n  var ins;\n\n  for (state.ip = 0; state.ip < pLen; state.ip++) {\n    if (exports.DEBUG) state.step++;\n    ins = instructionTable[prog[state.ip]];\n\n    if (!ins) {\n      throw new Error('unknown instruction: 0x' + Number(prog[state.ip]).toString(16));\n    }\n\n    ins(state); // very extensive debugging for each step\n\n    /*\n    if (exports.DEBUG) {\n        var da;\n        if (state.gZone) {\n            da = [];\n            for (let i = 0; i < state.gZone.length; i++)\n            {\n                da.push(i + ' ' +\n                    state.gZone[i].x * 64 + ' ' +\n                    state.gZone[i].y * 64 + ' ' +\n                    (state.gZone[i].xTouched ? 'x' : '') +\n                    (state.gZone[i].yTouched ? 'y' : '')\n                );\n            }\n            console.log('GZ', da);\n        }\n         if (state.tZone) {\n            da = [];\n            for (let i = 0; i < state.tZone.length; i++) {\n                da.push(i + ' ' +\n                    state.tZone[i].x * 64 + ' ' +\n                    state.tZone[i].y * 64 + ' ' +\n                    (state.tZone[i].xTouched ? 'x' : '') +\n                    (state.tZone[i].yTouched ? 'y' : '')\n                );\n            }\n            console.log('TZ', da);\n        }\n         if (state.stack.length > 10) {\n            console.log(\n                state.stack.length,\n                '...', state.stack.slice(state.stack.length - 10)\n            );\n        } else {\n            console.log(state.stack.length, state.stack);\n        }\n    }\n    */\n  }\n};\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\n\n\nfunction initTZone(state) {\n  var tZone = state.tZone = new Array(state.gZone.length); // no idea if this is actually correct...\n\n  for (var i = 0; i < tZone.length; i++) {\n    tZone[i] = new HPoint(0, 0);\n  }\n}\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\n\n\nfunction skip(state, handleElse) {\n  var prog = state.prog;\n  var ip = state.ip;\n  var nesting = 1;\n  var ins;\n\n  do {\n    ins = prog[++ip];\n    if (ins === 0x58) // IF\n      nesting++;else if (ins === 0x59) // EIF\n      nesting--;else if (ins === 0x40) // NPUSHB\n      ip += prog[ip + 1] + 1;else if (ins === 0x41) // NPUSHW\n      ip += 2 * prog[ip + 1] + 1;else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n      ip += ins - 0xB0 + 1;else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n      ip += (ins - 0xB8 + 1) * 2;else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n      break;\n  } while (nesting > 0);\n\n  state.ip = ip;\n}\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\n\n\nfunction SVTCA(v, state) {\n  if (exports.DEBUG) console.log(state.step, 'SVTCA[' + v.axis + ']');\n  state.fv = state.pv = state.dpv = v;\n} // SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\n\n\nfunction SPVTCA(v, state) {\n  if (exports.DEBUG) console.log(state.step, 'SPVTCA[' + v.axis + ']');\n  state.pv = state.dpv = v;\n} // SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\n\n\nfunction SFVTCA(v, state) {\n  if (exports.DEBUG) console.log(state.step, 'SFVTCA[' + v.axis + ']');\n  state.fv = v;\n} // SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\n\n\nfunction SPVTL(a, state) {\n  var stack = state.stack;\n  var p2i = stack.pop();\n  var p1i = stack.pop();\n  var p2 = state.z2[p2i];\n  var p1 = state.z1[p1i];\n  if (exports.DEBUG) console.log('SPVTL[' + a + ']', p2i, p1i);\n  var dx;\n  var dy;\n\n  if (!a) {\n    dx = p1.x - p2.x;\n    dy = p1.y - p2.y;\n  } else {\n    dx = p2.y - p1.y;\n    dy = p1.x - p2.x;\n  }\n\n  state.pv = state.dpv = getUnitVector(dx, dy);\n} // SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\n\n\nfunction SFVTL(a, state) {\n  var stack = state.stack;\n  var p2i = stack.pop();\n  var p1i = stack.pop();\n  var p2 = state.z2[p2i];\n  var p1 = state.z1[p1i];\n  if (exports.DEBUG) console.log('SFVTL[' + a + ']', p2i, p1i);\n  var dx;\n  var dy;\n\n  if (!a) {\n    dx = p1.x - p2.x;\n    dy = p1.y - p2.y;\n  } else {\n    dx = p2.y - p1.y;\n    dy = p1.x - p2.x;\n  }\n\n  state.fv = getUnitVector(dx, dy);\n} // SPVFS[] Set Projection Vector From Stack\n// 0x0A\n\n\nfunction SPVFS(state) {\n  var stack = state.stack;\n  var y = stack.pop();\n  var x = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n  state.pv = state.dpv = getUnitVector(x, y);\n} // SFVFS[] Set Freedom Vector From Stack\n// 0x0B\n\n\nfunction SFVFS(state) {\n  var stack = state.stack;\n  var y = stack.pop();\n  var x = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n  state.fv = getUnitVector(x, y);\n} // GPV[] Get Projection Vector\n// 0x0C\n\n\nfunction GPV(state) {\n  var stack = state.stack;\n  var pv = state.pv;\n  if (exports.DEBUG) console.log(state.step, 'GPV[]');\n  stack.push(pv.x * 0x4000);\n  stack.push(pv.y * 0x4000);\n} // GFV[] Get Freedom Vector\n// 0x0C\n\n\nfunction GFV(state) {\n  var stack = state.stack;\n  var fv = state.fv;\n  if (exports.DEBUG) console.log(state.step, 'GFV[]');\n  stack.push(fv.x * 0x4000);\n  stack.push(fv.y * 0x4000);\n} // SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\n\n\nfunction SFVTPV(state) {\n  state.fv = state.pv;\n  if (exports.DEBUG) console.log(state.step, 'SFVTPV[]');\n} // ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\n\n\nfunction ISECT(state) {\n  var stack = state.stack;\n  var pa0i = stack.pop();\n  var pa1i = stack.pop();\n  var pb0i = stack.pop();\n  var pb1i = stack.pop();\n  var pi = stack.pop();\n  var z0 = state.z0;\n  var z1 = state.z1;\n  var pa0 = z0[pa0i];\n  var pa1 = z0[pa1i];\n  var pb0 = z1[pb0i];\n  var pb1 = z1[pb1i];\n  var p = state.z2[pi];\n  if (exports.DEBUG) console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); // math from\n  // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n  var x1 = pa0.x;\n  var y1 = pa0.y;\n  var x2 = pa1.x;\n  var y2 = pa1.y;\n  var x3 = pb0.x;\n  var y3 = pb0.y;\n  var x4 = pb1.x;\n  var y4 = pb1.y;\n  var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n  var f1 = x1 * y2 - y1 * x2;\n  var f2 = x3 * y4 - y3 * x4;\n  p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n  p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n} // SRP0[] Set Reference Point 0\n// 0x10\n\n\nfunction SRP0(state) {\n  state.rp0 = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SRP0[]', state.rp0);\n} // SRP1[] Set Reference Point 1\n// 0x11\n\n\nfunction SRP1(state) {\n  state.rp1 = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SRP1[]', state.rp1);\n} // SRP1[] Set Reference Point 2\n// 0x12\n\n\nfunction SRP2(state) {\n  state.rp2 = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SRP2[]', state.rp2);\n} // SZP0[] Set Zone Pointer 0\n// 0x13\n\n\nfunction SZP0(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZP0[]', n);\n  state.zp0 = n;\n\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z0 = state.tZone;\n      break;\n\n    case 1:\n      state.z0 = state.gZone;\n      break;\n\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n} // SZP1[] Set Zone Pointer 1\n// 0x14\n\n\nfunction SZP1(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZP1[]', n);\n  state.zp1 = n;\n\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z1 = state.tZone;\n      break;\n\n    case 1:\n      state.z1 = state.gZone;\n      break;\n\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n} // SZP2[] Set Zone Pointer 2\n// 0x15\n\n\nfunction SZP2(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZP2[]', n);\n  state.zp2 = n;\n\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z2 = state.tZone;\n      break;\n\n    case 1:\n      state.z2 = state.gZone;\n      break;\n\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n} // SZPS[] Set Zone PointerS\n// 0x16\n\n\nfunction SZPS(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SZPS[]', n);\n  state.zp0 = state.zp1 = state.zp2 = n;\n\n  switch (n) {\n    case 0:\n      if (!state.tZone) initTZone(state);\n      state.z0 = state.z1 = state.z2 = state.tZone;\n      break;\n\n    case 1:\n      state.z0 = state.z1 = state.z2 = state.gZone;\n      break;\n\n    default:\n      throw new Error('Invalid zone pointer');\n  }\n} // SLOOP[] Set LOOP variable\n// 0x17\n\n\nfunction SLOOP(state) {\n  state.loop = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SLOOP[]', state.loop);\n} // RTG[] Round To Grid\n// 0x18\n\n\nfunction RTG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RTG[]');\n  state.round = roundToGrid;\n} // RTHG[] Round To Half Grid\n// 0x19\n\n\nfunction RTHG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RTHG[]');\n  state.round = roundToHalfGrid;\n} // SMD[] Set Minimum Distance\n// 0x1A\n\n\nfunction SMD(state) {\n  var d = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SMD[]', d);\n  state.minDis = d / 0x40;\n} // ELSE[] ELSE clause\n// 0x1B\n\n\nfunction ELSE(state) {\n  // This instruction has been reached by executing a then branch\n  // so it just skips ahead until matching EIF.\n  //\n  // In case the IF was negative the IF[] instruction already\n  // skipped forward over the ELSE[]\n  if (exports.DEBUG) console.log(state.step, 'ELSE[]');\n  skip(state, false);\n} // JMPR[] JuMP Relative\n// 0x1C\n\n\nfunction JMPR(state) {\n  var o = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'JMPR[]', o); // A jump by 1 would do nothing.\n\n  state.ip += o - 1;\n} // SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\n\n\nfunction SCVTCI(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SCVTCI[]', n);\n  state.cvCutIn = n / 0x40;\n} // DUP[] DUPlicate top stack element\n// 0x20\n\n\nfunction DUP(state) {\n  var stack = state.stack;\n  if (exports.DEBUG) console.log(state.step, 'DUP[]');\n  stack.push(stack[stack.length - 1]);\n} // POP[] POP top stack element\n// 0x21\n\n\nfunction POP(state) {\n  if (exports.DEBUG) console.log(state.step, 'POP[]');\n  state.stack.pop();\n} // CLEAR[] CLEAR the stack\n// 0x22\n\n\nfunction CLEAR(state) {\n  if (exports.DEBUG) console.log(state.step, 'CLEAR[]');\n  state.stack.length = 0;\n} // SWAP[] SWAP the top two elements on the stack\n// 0x23\n\n\nfunction SWAP(state) {\n  var stack = state.stack;\n  var a = stack.pop();\n  var b = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SWAP[]');\n  stack.push(a);\n  stack.push(b);\n} // DEPTH[] DEPTH of the stack\n// 0x24\n\n\nfunction DEPTH(state) {\n  var stack = state.stack;\n  if (exports.DEBUG) console.log(state.step, 'DEPTH[]');\n  stack.push(stack.length);\n} // LOOPCALL[] LOOPCALL function\n// 0x2A\n\n\nfunction LOOPCALL(state) {\n  var stack = state.stack;\n  var fn = stack.pop();\n  var c = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'LOOPCALL[]', fn, c); // saves callers program\n\n  var cip = state.ip;\n  var cprog = state.prog;\n  state.prog = state.funcs[fn]; // executes the function\n\n  for (var i = 0; i < c; i++) {\n    exec(state);\n    if (exports.DEBUG) console.log(++state.step, i + 1 < c ? 'next loopcall' : 'done loopcall', i);\n  } // restores the callers program\n\n\n  state.ip = cip;\n  state.prog = cprog;\n} // CALL[] CALL function\n// 0x2B\n\n\nfunction CALL(state) {\n  var fn = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'CALL[]', fn); // saves callers program\n\n  var cip = state.ip;\n  var cprog = state.prog;\n  state.prog = state.funcs[fn]; // executes the function\n\n  exec(state); // restores the callers program\n\n  state.ip = cip;\n  state.prog = cprog;\n  if (exports.DEBUG) console.log(++state.step, 'returning from', fn);\n} // CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\n\n\nfunction CINDEX(state) {\n  var stack = state.stack;\n  var k = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'CINDEX[]', k); // In case of k == 1, it copies the last element after popping\n  // thus stack.length - k.\n\n  stack.push(stack[stack.length - k]);\n} // MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\n\n\nfunction MINDEX(state) {\n  var stack = state.stack;\n  var k = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MINDEX[]', k);\n  stack.push(stack.splice(stack.length - k, 1)[0]);\n} // FDEF[] Function DEFinition\n// 0x2C\n\n\nfunction FDEF(state) {\n  if (state.env !== 'fpgm') throw new Error('FDEF not allowed here');\n  var stack = state.stack;\n  var prog = state.prog;\n  var ip = state.ip;\n  var fn = stack.pop();\n  var ipBegin = ip;\n  if (exports.DEBUG) console.log(state.step, 'FDEF[]', fn);\n\n  while (prog[++ip] !== 0x2D) {\n    ;\n  }\n\n  state.ip = ip;\n  state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n} // MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\n\n\nfunction MDAP(round, state) {\n  var pi = state.stack.pop();\n  var p = state.z0[pi];\n  var fv = state.fv;\n  var pv = state.pv;\n  if (exports.DEBUG) console.log(state.step, 'MDAP[' + round + ']', pi);\n  var d = pv.distance(p, HPZero);\n  if (round) d = state.round(d);\n  fv.setRelative(p, HPZero, d, pv);\n  fv.touch(p);\n  state.rp0 = state.rp1 = pi;\n} // IUP[a] Interpolate Untouched Points through the outline\n// 0x30\n\n\nfunction IUP(v, state) {\n  var z2 = state.z2;\n  var pLen = z2.length - 2;\n  var cp;\n  var pp;\n  var np;\n  if (exports.DEBUG) console.log(state.step, 'IUP[' + v.axis + ']');\n\n  for (var i = 0; i < pLen; i++) {\n    cp = z2[i]; // current point\n    // if this point has been touched go on\n\n    if (v.touched(cp)) continue;\n    pp = cp.prevTouched(v); // no point on the contour has been touched?\n\n    if (pp === cp) continue;\n    np = cp.nextTouched(v);\n\n    if (pp === np) {\n      // only one point on the contour has been touched\n      // so simply moves the point like that\n      v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n    }\n\n    v.interpolate(cp, pp, np, v);\n  }\n} // SHP[] SHift Point using reference point\n// 0x32-0x33\n\n\nfunction SHP(a, state) {\n  var stack = state.stack;\n  var rpi = a ? state.rp1 : state.rp2;\n  var rp = (a ? state.z0 : state.z1)[rpi];\n  var fv = state.fv;\n  var pv = state.pv;\n  var loop = state.loop;\n  var z2 = state.z2;\n\n  while (loop--) {\n    var pi = stack.pop();\n    var p = z2[pi];\n    var d = pv.distance(rp, rp, false, true);\n    fv.setRelative(p, p, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi);\n    }\n  }\n\n  state.loop = 1;\n} // SHC[] SHift Contour using reference point\n// 0x36-0x37\n\n\nfunction SHC(a, state) {\n  var stack = state.stack;\n  var rpi = a ? state.rp1 : state.rp2;\n  var rp = (a ? state.z0 : state.z1)[rpi];\n  var fv = state.fv;\n  var pv = state.pv;\n  var ci = stack.pop();\n  var sp = state.z2[state.contours[ci]];\n  var p = sp;\n  if (exports.DEBUG) console.log(state.step, 'SHC[' + a + ']', ci);\n  var d = pv.distance(rp, rp, false, true);\n\n  do {\n    if (p !== rp) fv.setRelative(p, p, d, pv);\n    p = p.nextPointOnContour;\n  } while (p !== sp);\n} // SHZ[] SHift Zone using reference point\n// 0x36-0x37\n\n\nfunction SHZ(a, state) {\n  var stack = state.stack;\n  var rpi = a ? state.rp1 : state.rp2;\n  var rp = (a ? state.z0 : state.z1)[rpi];\n  var fv = state.fv;\n  var pv = state.pv;\n  var e = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SHZ[' + a + ']', e);\n  var z;\n\n  switch (e) {\n    case 0:\n      z = state.tZone;\n      break;\n\n    case 1:\n      z = state.gZone;\n      break;\n\n    default:\n      throw new Error('Invalid zone');\n  }\n\n  var p;\n  var d = pv.distance(rp, rp, false, true);\n  var pLen = z.length - 2;\n\n  for (var i = 0; i < pLen; i++) {\n    p = z[i];\n    fv.setRelative(p, p, d, pv); //if (p !== rp) fv.setRelative(p, p, d, pv);\n  }\n} // SHPIX[] SHift point by a PIXel amount\n// 0x38\n\n\nfunction SHPIX(state) {\n  var stack = state.stack;\n  var loop = state.loop;\n  var fv = state.fv;\n  var d = stack.pop() / 0x40;\n  var z2 = state.z2;\n\n  while (loop--) {\n    var pi = stack.pop();\n    var p = z2[pi];\n\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHPIX[]', pi, d);\n    }\n\n    fv.setRelative(p, p, d);\n    fv.touch(p);\n  }\n\n  state.loop = 1;\n} // IP[] Interpolate Point\n// 0x39\n\n\nfunction IP(state) {\n  var stack = state.stack;\n  var rp1i = state.rp1;\n  var rp2i = state.rp2;\n  var loop = state.loop;\n  var rp1 = state.z0[rp1i];\n  var rp2 = state.z1[rp2i];\n  var fv = state.fv;\n  var pv = state.dpv;\n  var z2 = state.z2;\n\n  while (loop--) {\n    var pi = stack.pop();\n    var p = z2[pi];\n\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'IP[]', pi, rp1i, '<->', rp2i);\n    }\n\n    fv.interpolate(p, rp1, rp2, pv);\n    fv.touch(p);\n  }\n\n  state.loop = 1;\n} // MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\n\n\nfunction MSIRP(a, state) {\n  var stack = state.stack;\n  var d = stack.pop() / 64;\n  var pi = stack.pop();\n  var p = state.z1[pi];\n  var rp0 = state.z0[state.rp0];\n  var fv = state.fv;\n  var pv = state.pv;\n  fv.setRelative(p, rp0, d, pv);\n  fv.touch(p);\n  if (exports.DEBUG) console.log(state.step, 'MSIRP[' + a + ']', d, pi);\n  state.rp1 = state.rp0;\n  state.rp2 = pi;\n  if (a) state.rp0 = pi;\n} // ALIGNRP[] Align to reference point.\n// 0x3C\n\n\nfunction ALIGNRP(state) {\n  var stack = state.stack;\n  var rp0i = state.rp0;\n  var rp0 = state.z0[rp0i];\n  var loop = state.loop;\n  var fv = state.fv;\n  var pv = state.pv;\n  var z1 = state.z1;\n\n  while (loop--) {\n    var pi = stack.pop();\n    var p = z1[pi];\n\n    if (exports.DEBUG) {\n      console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'ALIGNRP[]', pi);\n    }\n\n    fv.setRelative(p, rp0, 0, pv);\n    fv.touch(p);\n  }\n\n  state.loop = 1;\n} // RTG[] Round To Double Grid\n// 0x3D\n\n\nfunction RTDG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RTDG[]');\n  state.round = roundToDoubleGrid;\n} // MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\n\n\nfunction MIAP(round, state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  var pi = stack.pop();\n  var p = state.z0[pi];\n  var fv = state.fv;\n  var pv = state.pv;\n  var cv = state.cvt[n];\n\n  if (exports.DEBUG) {\n    console.log(state.step, 'MIAP[' + round + ']', n, '(', cv, ')', pi);\n  }\n\n  var d = pv.distance(p, HPZero);\n\n  if (round) {\n    if (Math.abs(d - cv) < state.cvCutIn) d = cv;\n    d = state.round(d);\n  }\n\n  fv.setRelative(p, HPZero, d, pv);\n\n  if (state.zp0 === 0) {\n    p.xo = p.x;\n    p.yo = p.y;\n  }\n\n  fv.touch(p);\n  state.rp0 = state.rp1 = pi;\n} // NPUSB[] PUSH N Bytes\n// 0x40\n\n\nfunction NPUSHB(state) {\n  var prog = state.prog;\n  var ip = state.ip;\n  var stack = state.stack;\n  var n = prog[++ip];\n  if (exports.DEBUG) console.log(state.step, 'NPUSHB[]', n);\n\n  for (var i = 0; i < n; i++) {\n    stack.push(prog[++ip]);\n  }\n\n  state.ip = ip;\n} // NPUSHW[] PUSH N Words\n// 0x41\n\n\nfunction NPUSHW(state) {\n  var ip = state.ip;\n  var prog = state.prog;\n  var stack = state.stack;\n  var n = prog[++ip];\n  if (exports.DEBUG) console.log(state.step, 'NPUSHW[]', n);\n\n  for (var i = 0; i < n; i++) {\n    var w = prog[++ip] << 8 | prog[++ip];\n    if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n    stack.push(w);\n  }\n\n  state.ip = ip;\n} // WS[] Write Store\n// 0x42\n\n\nfunction WS(state) {\n  var stack = state.stack;\n  var store = state.store;\n  if (!store) store = state.store = [];\n  var v = stack.pop();\n  var l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'WS', v, l);\n  store[l] = v;\n} // RS[] Read Store\n// 0x43\n\n\nfunction RS(state) {\n  var stack = state.stack;\n  var store = state.store;\n  var l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'RS', l);\n  var v = store && store[l] || 0;\n  stack.push(v);\n} // WCVTP[] Write Control Value Table in Pixel units\n// 0x44\n\n\nfunction WCVTP(state) {\n  var stack = state.stack;\n  var v = stack.pop();\n  var l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'WCVTP', v, l);\n  state.cvt[l] = v / 0x40;\n} // RCVT[] Read Control Value Table entry\n// 0x45\n\n\nfunction RCVT(state) {\n  var stack = state.stack;\n  var cvte = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'RCVT', cvte);\n  stack.push(state.cvt[cvte] * 0x40);\n} // GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\n\n\nfunction GC(a, state) {\n  var stack = state.stack;\n  var pi = stack.pop();\n  var p = state.z2[pi];\n  if (exports.DEBUG) console.log(state.step, 'GC[' + a + ']', pi);\n  stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n} // MD[a] Measure Distance\n// 0x49-0x4A\n\n\nfunction MD(a, state) {\n  var stack = state.stack;\n  var pi2 = stack.pop();\n  var pi1 = stack.pop();\n  var p2 = state.z1[pi2];\n  var p1 = state.z0[pi1];\n  var d = state.dpv.distance(p1, p2, a, a);\n  if (exports.DEBUG) console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d);\n  state.stack.push(Math.round(d * 64));\n} // MPPEM[] Measure Pixels Per EM\n// 0x4B\n\n\nfunction MPPEM(state) {\n  if (exports.DEBUG) console.log(state.step, 'MPPEM[]');\n  state.stack.push(state.ppem);\n} // FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\n\n\nfunction FLIPON(state) {\n  if (exports.DEBUG) console.log(state.step, 'FLIPON[]');\n  state.autoFlip = true;\n} // LT[] Less Than\n// 0x50\n\n\nfunction LT(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'LT[]', e2, e1);\n  stack.push(e1 < e2 ? 1 : 0);\n} // LTEQ[] Less Than or EQual\n// 0x53\n\n\nfunction LTEQ(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'LTEQ[]', e2, e1);\n  stack.push(e1 <= e2 ? 1 : 0);\n} // GTEQ[] Greater Than\n// 0x52\n\n\nfunction GT(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'GT[]', e2, e1);\n  stack.push(e1 > e2 ? 1 : 0);\n} // GTEQ[] Greater Than or EQual\n// 0x53\n\n\nfunction GTEQ(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'GTEQ[]', e2, e1);\n  stack.push(e1 >= e2 ? 1 : 0);\n} // EQ[] EQual\n// 0x54\n\n\nfunction EQ(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'EQ[]', e2, e1);\n  stack.push(e2 === e1 ? 1 : 0);\n} // NEQ[] Not EQual\n// 0x55\n\n\nfunction NEQ(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'NEQ[]', e2, e1);\n  stack.push(e2 !== e1 ? 1 : 0);\n} // ODD[] ODD\n// 0x56\n\n\nfunction ODD(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ODD[]', n);\n  stack.push(Math.trunc(n) % 2 ? 1 : 0);\n} // EVEN[] EVEN\n// 0x57\n\n\nfunction EVEN(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'EVEN[]', n);\n  stack.push(Math.trunc(n) % 2 ? 0 : 1);\n} // IF[] IF test\n// 0x58\n\n\nfunction IF(state) {\n  var test = state.stack.pop();\n  var ins;\n  if (exports.DEBUG) console.log(state.step, 'IF[]', test); // if test is true it just continues\n  // if not the ip is skipped until matching ELSE or EIF\n\n  if (!test) {\n    skip(state, true);\n    if (exports.DEBUG) console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]');\n  }\n} // EIF[] End IF\n// 0x59\n\n\nfunction EIF(state) {\n  // this can be reached normally when\n  // executing an else branch.\n  // -> just ignore it\n  if (exports.DEBUG) console.log(state.step, 'EIF[]');\n} // AND[] logical AND\n// 0x5A\n\n\nfunction AND(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'AND[]', e2, e1);\n  stack.push(e2 && e1 ? 1 : 0);\n} // OR[] logical OR\n// 0x5B\n\n\nfunction OR(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'OR[]', e2, e1);\n  stack.push(e2 || e1 ? 1 : 0);\n} // NOT[] logical NOT\n// 0x5C\n\n\nfunction NOT(state) {\n  var stack = state.stack;\n  var e = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'NOT[]', e);\n  stack.push(e ? 0 : 1);\n} // DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\n\n\nfunction DELTAP123(b, state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  var fv = state.fv;\n  var pv = state.pv;\n  var ppem = state.ppem;\n  var base = state.deltaBase + (b - 1) * 16;\n  var ds = state.deltaShift;\n  var z0 = state.z0;\n  if (exports.DEBUG) console.log(state.step, 'DELTAP[' + b + ']', n, stack);\n\n  for (var i = 0; i < n; i++) {\n    var pi = stack.pop();\n    var arg = stack.pop();\n    var appem = base + ((arg & 0xF0) >> 4);\n    if (appem !== ppem) continue;\n    var mag = (arg & 0x0F) - 8;\n    if (mag >= 0) mag++;\n    if (exports.DEBUG) console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds);\n    var p = z0[pi];\n    fv.setRelative(p, p, mag * ds, pv);\n  }\n} // SDB[] Set Delta Base in the graphics state\n// 0x5E\n\n\nfunction SDB(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SDB[]', n);\n  state.deltaBase = n;\n} // SDS[] Set Delta Shift in the graphics state\n// 0x5F\n\n\nfunction SDS(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SDS[]', n);\n  state.deltaShift = Math.pow(0.5, n);\n} // ADD[] ADD\n// 0x60\n\n\nfunction ADD(state) {\n  var stack = state.stack;\n  var n2 = stack.pop();\n  var n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ADD[]', n2, n1);\n  stack.push(n1 + n2);\n} // SUB[] SUB\n// 0x61\n\n\nfunction SUB(state) {\n  var stack = state.stack;\n  var n2 = stack.pop();\n  var n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SUB[]', n2, n1);\n  stack.push(n1 - n2);\n} // DIV[] DIV\n// 0x62\n\n\nfunction DIV(state) {\n  var stack = state.stack;\n  var n2 = stack.pop();\n  var n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'DIV[]', n2, n1);\n  stack.push(n1 * 64 / n2);\n} // MUL[] MUL\n// 0x63\n\n\nfunction MUL(state) {\n  var stack = state.stack;\n  var n2 = stack.pop();\n  var n1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MUL[]', n2, n1);\n  stack.push(n1 * n2 / 64);\n} // ABS[] ABSolute value\n// 0x64\n\n\nfunction ABS(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ABS[]', n);\n  stack.push(Math.abs(n));\n} // NEG[] NEGate\n// 0x65\n\n\nfunction NEG(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'NEG[]', n);\n  stack.push(-n);\n} // FLOOR[] FLOOR\n// 0x66\n\n\nfunction FLOOR(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'FLOOR[]', n);\n  stack.push(Math.floor(n / 0x40) * 0x40);\n} // CEILING[] CEILING\n// 0x67\n\n\nfunction CEILING(state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'CEILING[]', n);\n  stack.push(Math.ceil(n / 0x40) * 0x40);\n} // ROUND[ab] ROUND value\n// 0x68-0x6B\n\n\nfunction ROUND(dt, state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ROUND[]');\n  stack.push(state.round(n / 0x40) * 0x40);\n} // WCVTF[] Write Control Value Table in Funits\n// 0x70\n\n\nfunction WCVTF(state) {\n  var stack = state.stack;\n  var v = stack.pop();\n  var l = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'WCVTF[]', v, l);\n  state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n} // DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\n\n\nfunction DELTAC123(b, state) {\n  var stack = state.stack;\n  var n = stack.pop();\n  var ppem = state.ppem;\n  var base = state.deltaBase + (b - 1) * 16;\n  var ds = state.deltaShift;\n  if (exports.DEBUG) console.log(state.step, 'DELTAC[' + b + ']', n, stack);\n\n  for (var i = 0; i < n; i++) {\n    var c = stack.pop();\n    var arg = stack.pop();\n    var appem = base + ((arg & 0xF0) >> 4);\n    if (appem !== ppem) continue;\n    var mag = (arg & 0x0F) - 8;\n    if (mag >= 0) mag++;\n    var delta = mag * ds;\n    if (exports.DEBUG) console.log(state.step, 'DELTACFIX', c, 'by', delta);\n    state.cvt[c] += delta;\n  }\n} // SROUND[] Super ROUND\n// 0x76\n\n\nfunction SROUND(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'SROUND[]', n);\n  state.round = roundSuper;\n  var period;\n\n  switch (n & 0xC0) {\n    case 0x00:\n      period = 0.5;\n      break;\n\n    case 0x40:\n      period = 1;\n      break;\n\n    case 0x80:\n      period = 2;\n      break;\n\n    default:\n      throw new Error('invalid SROUND value');\n  }\n\n  state.srPeriod = period;\n\n  switch (n & 0x30) {\n    case 0x00:\n      state.srPhase = 0;\n      break;\n\n    case 0x10:\n      state.srPhase = 0.25 * period;\n      break;\n\n    case 0x20:\n      state.srPhase = 0.5 * period;\n      break;\n\n    case 0x30:\n      state.srPhase = 0.75 * period;\n      break;\n\n    default:\n      throw new Error('invalid SROUND value');\n  }\n\n  n &= 0x0F;\n  if (n === 0) state.srThreshold = 0;else state.srThreshold = (n / 8 - 0.5) * period;\n} // S45ROUND[] Super ROUND 45 degrees\n// 0x77\n\n\nfunction S45ROUND(state) {\n  var n = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'S45ROUND[]', n);\n  state.round = roundSuper;\n  var period;\n\n  switch (n & 0xC0) {\n    case 0x00:\n      period = Math.sqrt(2) / 2;\n      break;\n\n    case 0x40:\n      period = Math.sqrt(2);\n      break;\n\n    case 0x80:\n      period = 2 * Math.sqrt(2);\n      break;\n\n    default:\n      throw new Error('invalid S45ROUND value');\n  }\n\n  state.srPeriod = period;\n\n  switch (n & 0x30) {\n    case 0x00:\n      state.srPhase = 0;\n      break;\n\n    case 0x10:\n      state.srPhase = 0.25 * period;\n      break;\n\n    case 0x20:\n      state.srPhase = 0.5 * period;\n      break;\n\n    case 0x30:\n      state.srPhase = 0.75 * period;\n      break;\n\n    default:\n      throw new Error('invalid S45ROUND value');\n  }\n\n  n &= 0x0F;\n  if (n === 0) state.srThreshold = 0;else state.srThreshold = (n / 8 - 0.5) * period;\n} // ROFF[] Round Off\n// 0x7A\n\n\nfunction ROFF(state) {\n  if (exports.DEBUG) console.log(state.step, 'ROFF[]');\n  state.round = roundOff;\n} // RUTG[] Round Up To Grid\n// 0x7C\n\n\nfunction RUTG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RUTG[]');\n  state.round = roundUpToGrid;\n} // RDTG[] Round Down To Grid\n// 0x7D\n\n\nfunction RDTG(state) {\n  if (exports.DEBUG) console.log(state.step, 'RDTG[]');\n  state.round = roundDownToGrid;\n} // SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\n\n\nfunction SCANCTRL(state) {\n  var n = state.stack.pop(); // ignored by opentype.js\n\n  if (exports.DEBUG) console.log(state.step, 'SCANCTRL[]', n);\n} // SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\n\n\nfunction SDPVTL(a, state) {\n  var stack = state.stack;\n  var p2i = stack.pop();\n  var p1i = stack.pop();\n  var p2 = state.z2[p2i];\n  var p1 = state.z1[p1i];\n  if (exports.DEBUG) console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i);\n  var dx;\n  var dy;\n\n  if (!a) {\n    dx = p1.x - p2.x;\n    dy = p1.y - p2.y;\n  } else {\n    dx = p2.y - p1.y;\n    dy = p1.x - p2.x;\n  }\n\n  state.dpv = getUnitVector(dx, dy);\n} // GETINFO[] GET INFOrmation\n// 0x88\n\n\nfunction GETINFO(state) {\n  var stack = state.stack;\n  var sel = stack.pop();\n  var r = 0;\n  if (exports.DEBUG) console.log(state.step, 'GETINFO[]', sel); // v35 as in no subpixel hinting\n\n  if (sel & 0x01) r = 35; // TODO rotation and stretch currently not supported\n  // and thus those GETINFO are always 0.\n  // opentype.js is always gray scaling\n\n  if (sel & 0x20) r |= 0x1000;\n  stack.push(r);\n} // ROLL[] ROLL the top three stack elements\n// 0x8A\n\n\nfunction ROLL(state) {\n  var stack = state.stack;\n  var a = stack.pop();\n  var b = stack.pop();\n  var c = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'ROLL[]');\n  stack.push(b);\n  stack.push(a);\n  stack.push(c);\n} // MAX[] MAXimum of top two stack elements\n// 0x8B\n\n\nfunction MAX(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MAX[]', e2, e1);\n  stack.push(Math.max(e1, e2));\n} // MIN[] MINimum of top two stack elements\n// 0x8C\n\n\nfunction MIN(state) {\n  var stack = state.stack;\n  var e2 = stack.pop();\n  var e1 = stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'MIN[]', e2, e1);\n  stack.push(Math.min(e1, e2));\n} // SCANTYPE[] SCANTYPE\n// 0x8D\n\n\nfunction SCANTYPE(state) {\n  var n = state.stack.pop(); // ignored by opentype.js\n\n  if (exports.DEBUG) console.log(state.step, 'SCANTYPE[]', n);\n} // INSTCTRL[] INSTCTRL\n// 0x8D\n\n\nfunction INSTCTRL(state) {\n  var s = state.stack.pop();\n  var v = state.stack.pop();\n  if (exports.DEBUG) console.log(state.step, 'INSTCTRL[]', s, v);\n\n  switch (s) {\n    case 1:\n      state.inhibitGridFit = !!v;\n      return;\n\n    case 2:\n      state.ignoreCvt = !!v;\n      return;\n\n    default:\n      throw new Error('invalid INSTCTRL[] selector');\n  }\n} // PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\n\n\nfunction PUSHB(n, state) {\n  var stack = state.stack;\n  var prog = state.prog;\n  var ip = state.ip;\n  if (exports.DEBUG) console.log(state.step, 'PUSHB[' + n + ']');\n\n  for (var i = 0; i < n; i++) {\n    stack.push(prog[++ip]);\n  }\n\n  state.ip = ip;\n} // PUSHW[abc] PUSH Words\n// 0xB8-0xBF\n\n\nfunction PUSHW(n, state) {\n  var ip = state.ip;\n  var prog = state.prog;\n  var stack = state.stack;\n  if (exports.DEBUG) console.log(state.ip, 'PUSHW[' + n + ']');\n\n  for (var i = 0; i < n; i++) {\n    var w = prog[++ip] << 8 | prog[++ip];\n    if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n    stack.push(w);\n  }\n\n  state.ip = ip;\n} // MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n  var stack = state.stack;\n  var cvte = indirect && stack.pop();\n  var pi = stack.pop();\n  var rp0i = state.rp0;\n  var rp = state.z0[rp0i];\n  var p = state.z1[pi];\n  var md = state.minDis;\n  var fv = state.fv;\n  var pv = state.dpv;\n  var od; // original distance\n\n  var d; // moving distance\n\n  var sign; // sign of distance\n\n  var cv;\n  d = od = pv.distance(p, rp, true, true);\n  sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n  // TODO consider autoFlip\n\n  d = Math.abs(d);\n\n  if (indirect) {\n    cv = state.cvt[cvte];\n    if (ro && Math.abs(d - cv) < state.cvCutIn) d = cv;\n  }\n\n  if (keepD && d < md) d = md;\n  if (ro) d = state.round(d);\n  fv.setRelative(p, rp, sign * d, pv);\n  fv.touch(p);\n\n  if (exports.DEBUG) {\n    console.log(state.step, (indirect ? 'MIRP[' : 'MDRP[') + (setRp0 ? 'M' : 'm') + (keepD ? '>' : '_') + (ro ? 'R' : '_') + (dt === 0 ? 'Gr' : dt === 1 ? 'Bl' : dt === 2 ? 'Wh' : '') + ']', indirect ? cvte + '(' + state.cvt[cvte] + ',' + cv + ')' : '', pi, '(d =', od, '->', sign * d, ')');\n  }\n\n  state.rp1 = state.rp0;\n  state.rp2 = pi;\n  if (setRp0) state.rp0 = pi;\n}\n/*\n* The instruction table.\n*/\n\n\ninstructionTable = [\n/* 0x00 */\nSVTCA.bind(undefined, yUnitVector),\n/* 0x01 */\nSVTCA.bind(undefined, xUnitVector),\n/* 0x02 */\nSPVTCA.bind(undefined, yUnitVector),\n/* 0x03 */\nSPVTCA.bind(undefined, xUnitVector),\n/* 0x04 */\nSFVTCA.bind(undefined, yUnitVector),\n/* 0x05 */\nSFVTCA.bind(undefined, xUnitVector),\n/* 0x06 */\nSPVTL.bind(undefined, 0),\n/* 0x07 */\nSPVTL.bind(undefined, 1),\n/* 0x08 */\nSFVTL.bind(undefined, 0),\n/* 0x09 */\nSFVTL.bind(undefined, 1),\n/* 0x0A */\nSPVFS,\n/* 0x0B */\nSFVFS,\n/* 0x0C */\nGPV,\n/* 0x0D */\nGFV,\n/* 0x0E */\nSFVTPV,\n/* 0x0F */\nISECT,\n/* 0x10 */\nSRP0,\n/* 0x11 */\nSRP1,\n/* 0x12 */\nSRP2,\n/* 0x13 */\nSZP0,\n/* 0x14 */\nSZP1,\n/* 0x15 */\nSZP2,\n/* 0x16 */\nSZPS,\n/* 0x17 */\nSLOOP,\n/* 0x18 */\nRTG,\n/* 0x19 */\nRTHG,\n/* 0x1A */\nSMD,\n/* 0x1B */\nELSE,\n/* 0x1C */\nJMPR,\n/* 0x1D */\nSCVTCI,\n/* 0x1E */\nundefined, // TODO SSWCI\n\n/* 0x1F */\nundefined, // TODO SSW\n\n/* 0x20 */\nDUP,\n/* 0x21 */\nPOP,\n/* 0x22 */\nCLEAR,\n/* 0x23 */\nSWAP,\n/* 0x24 */\nDEPTH,\n/* 0x25 */\nCINDEX,\n/* 0x26 */\nMINDEX,\n/* 0x27 */\nundefined, // TODO ALIGNPTS\n\n/* 0x28 */\nundefined,\n/* 0x29 */\nundefined, // TODO UTP\n\n/* 0x2A */\nLOOPCALL,\n/* 0x2B */\nCALL,\n/* 0x2C */\nFDEF,\n/* 0x2D */\nundefined, // ENDF (eaten by FDEF)\n\n/* 0x2E */\nMDAP.bind(undefined, 0),\n/* 0x2F */\nMDAP.bind(undefined, 1),\n/* 0x30 */\nIUP.bind(undefined, yUnitVector),\n/* 0x31 */\nIUP.bind(undefined, xUnitVector),\n/* 0x32 */\nSHP.bind(undefined, 0),\n/* 0x33 */\nSHP.bind(undefined, 1),\n/* 0x34 */\nSHC.bind(undefined, 0),\n/* 0x35 */\nSHC.bind(undefined, 1),\n/* 0x36 */\nSHZ.bind(undefined, 0),\n/* 0x37 */\nSHZ.bind(undefined, 1),\n/* 0x38 */\nSHPIX,\n/* 0x39 */\nIP,\n/* 0x3A */\nMSIRP.bind(undefined, 0),\n/* 0x3B */\nMSIRP.bind(undefined, 1),\n/* 0x3C */\nALIGNRP,\n/* 0x3D */\nRTDG,\n/* 0x3E */\nMIAP.bind(undefined, 0),\n/* 0x3F */\nMIAP.bind(undefined, 1),\n/* 0x40 */\nNPUSHB,\n/* 0x41 */\nNPUSHW,\n/* 0x42 */\nWS,\n/* 0x43 */\nRS,\n/* 0x44 */\nWCVTP,\n/* 0x45 */\nRCVT,\n/* 0x46 */\nGC.bind(undefined, 0),\n/* 0x47 */\nGC.bind(undefined, 1),\n/* 0x48 */\nundefined, // TODO SCFS\n\n/* 0x49 */\nMD.bind(undefined, 0),\n/* 0x4A */\nMD.bind(undefined, 1),\n/* 0x4B */\nMPPEM,\n/* 0x4C */\nundefined, // TODO MPS\n\n/* 0x4D */\nFLIPON,\n/* 0x4E */\nundefined, // TODO FLIPOFF\n\n/* 0x4F */\nundefined, // TODO DEBUG\n\n/* 0x50 */\nLT,\n/* 0x51 */\nLTEQ,\n/* 0x52 */\nGT,\n/* 0x53 */\nGTEQ,\n/* 0x54 */\nEQ,\n/* 0x55 */\nNEQ,\n/* 0x56 */\nODD,\n/* 0x57 */\nEVEN,\n/* 0x58 */\nIF,\n/* 0x59 */\nEIF,\n/* 0x5A */\nAND,\n/* 0x5B */\nOR,\n/* 0x5C */\nNOT,\n/* 0x5D */\nDELTAP123.bind(undefined, 1),\n/* 0x5E */\nSDB,\n/* 0x5F */\nSDS,\n/* 0x60 */\nADD,\n/* 0x61 */\nSUB,\n/* 0x62 */\nDIV,\n/* 0x63 */\nMUL,\n/* 0x64 */\nABS,\n/* 0x65 */\nNEG,\n/* 0x66 */\nFLOOR,\n/* 0x67 */\nCEILING,\n/* 0x68 */\nROUND.bind(undefined, 0),\n/* 0x69 */\nROUND.bind(undefined, 1),\n/* 0x6A */\nROUND.bind(undefined, 2),\n/* 0x6B */\nROUND.bind(undefined, 3),\n/* 0x6C */\nundefined, // TODO NROUND[ab]\n\n/* 0x6D */\nundefined, // TODO NROUND[ab]\n\n/* 0x6E */\nundefined, // TODO NROUND[ab]\n\n/* 0x6F */\nundefined, // TODO NROUND[ab]\n\n/* 0x70 */\nWCVTF,\n/* 0x71 */\nDELTAP123.bind(undefined, 2),\n/* 0x72 */\nDELTAP123.bind(undefined, 3),\n/* 0x73 */\nDELTAC123.bind(undefined, 1),\n/* 0x74 */\nDELTAC123.bind(undefined, 2),\n/* 0x75 */\nDELTAC123.bind(undefined, 3),\n/* 0x76 */\nSROUND,\n/* 0x77 */\nS45ROUND,\n/* 0x78 */\nundefined, // TODO JROT[]\n\n/* 0x79 */\nundefined, // TODO JROF[]\n\n/* 0x7A */\nROFF,\n/* 0x7B */\nundefined,\n/* 0x7C */\nRUTG,\n/* 0x7D */\nRDTG,\n/* 0x7E */\nPOP, // actually SANGW, supposed to do only a pop though\n\n/* 0x7F */\nPOP, // actually AA, supposed to do only a pop though\n\n/* 0x80 */\nundefined, // TODO FLIPPT\n\n/* 0x81 */\nundefined, // TODO FLIPRGON\n\n/* 0x82 */\nundefined, // TODO FLIPRGOFF\n\n/* 0x83 */\nundefined,\n/* 0x84 */\nundefined,\n/* 0x85 */\nSCANCTRL,\n/* 0x86 */\nSDPVTL.bind(undefined, 0),\n/* 0x87 */\nSDPVTL.bind(undefined, 1),\n/* 0x88 */\nGETINFO,\n/* 0x89 */\nundefined, // TODO IDEF\n\n/* 0x8A */\nROLL,\n/* 0x8B */\nMAX,\n/* 0x8C */\nMIN,\n/* 0x8D */\nSCANTYPE,\n/* 0x8E */\nINSTCTRL,\n/* 0x8F */\nundefined,\n/* 0x90 */\nundefined,\n/* 0x91 */\nundefined,\n/* 0x92 */\nundefined,\n/* 0x93 */\nundefined,\n/* 0x94 */\nundefined,\n/* 0x95 */\nundefined,\n/* 0x96 */\nundefined,\n/* 0x97 */\nundefined,\n/* 0x98 */\nundefined,\n/* 0x99 */\nundefined,\n/* 0x9A */\nundefined,\n/* 0x9B */\nundefined,\n/* 0x9C */\nundefined,\n/* 0x9D */\nundefined,\n/* 0x9E */\nundefined,\n/* 0x9F */\nundefined,\n/* 0xA0 */\nundefined,\n/* 0xA1 */\nundefined,\n/* 0xA2 */\nundefined,\n/* 0xA3 */\nundefined,\n/* 0xA4 */\nundefined,\n/* 0xA5 */\nundefined,\n/* 0xA6 */\nundefined,\n/* 0xA7 */\nundefined,\n/* 0xA8 */\nundefined,\n/* 0xA9 */\nundefined,\n/* 0xAA */\nundefined,\n/* 0xAB */\nundefined,\n/* 0xAC */\nundefined,\n/* 0xAD */\nundefined,\n/* 0xAE */\nundefined,\n/* 0xAF */\nundefined,\n/* 0xB0 */\nPUSHB.bind(undefined, 1),\n/* 0xB1 */\nPUSHB.bind(undefined, 2),\n/* 0xB2 */\nPUSHB.bind(undefined, 3),\n/* 0xB3 */\nPUSHB.bind(undefined, 4),\n/* 0xB4 */\nPUSHB.bind(undefined, 5),\n/* 0xB5 */\nPUSHB.bind(undefined, 6),\n/* 0xB6 */\nPUSHB.bind(undefined, 7),\n/* 0xB7 */\nPUSHB.bind(undefined, 8),\n/* 0xB8 */\nPUSHW.bind(undefined, 1),\n/* 0xB9 */\nPUSHW.bind(undefined, 2),\n/* 0xBA */\nPUSHW.bind(undefined, 3),\n/* 0xBB */\nPUSHW.bind(undefined, 4),\n/* 0xBC */\nPUSHW.bind(undefined, 5),\n/* 0xBD */\nPUSHW.bind(undefined, 6),\n/* 0xBE */\nPUSHW.bind(undefined, 7),\n/* 0xBF */\nPUSHW.bind(undefined, 8),\n/* 0xC0 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n/* 0xC1 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n/* 0xC2 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n/* 0xC3 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n/* 0xC4 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n/* 0xC5 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n/* 0xC6 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n/* 0xC7 */\nMDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n/* 0xC8 */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n/* 0xC9 */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n/* 0xCA */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n/* 0xCB */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n/* 0xCC */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n/* 0xCD */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n/* 0xCE */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n/* 0xCF */\nMDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n/* 0xD0 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n/* 0xD1 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n/* 0xD2 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n/* 0xD3 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n/* 0xD4 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n/* 0xD5 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n/* 0xD6 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n/* 0xD7 */\nMDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n/* 0xD8 */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n/* 0xD9 */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n/* 0xDA */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n/* 0xDB */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n/* 0xDC */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n/* 0xDD */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n/* 0xDE */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n/* 0xDF */\nMDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n/* 0xE0 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n/* 0xE1 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n/* 0xE2 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n/* 0xE3 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n/* 0xE4 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n/* 0xE5 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n/* 0xE6 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n/* 0xE7 */\nMDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n/* 0xE8 */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n/* 0xE9 */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n/* 0xEA */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n/* 0xEB */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n/* 0xEC */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n/* 0xED */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n/* 0xEE */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n/* 0xEF */\nMDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n/* 0xF0 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n/* 0xF1 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n/* 0xF2 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n/* 0xF3 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n/* 0xF4 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n/* 0xF5 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n/* 0xF6 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n/* 0xF7 */\nMDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n/* 0xF8 */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n/* 0xF9 */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n/* 0xFA */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n/* 0xFB */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n/* 0xFC */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n/* 0xFD */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n/* 0xFE */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n/* 0xFF */\nMDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)];\nexport default Hinting;\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90 \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/","map":null,"metadata":{},"sourceType":"module"}