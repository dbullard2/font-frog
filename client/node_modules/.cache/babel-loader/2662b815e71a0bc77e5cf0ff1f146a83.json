{"ast":null,"code":"// Parsing utility functions\nimport check from './check'; // Retrieve an unsigned byte from the DataView.\n\nfunction getByte(dataView, offset) {\n  return dataView.getUint8(offset);\n} // Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\n\n\nfunction getUShort(dataView, offset) {\n  return dataView.getUint16(offset, false);\n} // Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\n\n\nfunction getShort(dataView, offset) {\n  return dataView.getInt16(offset, false);\n} // Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\n\n\nfunction getULong(dataView, offset) {\n  return dataView.getUint32(offset, false);\n} // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\n\n\nfunction getFixed(dataView, offset) {\n  var decimal = dataView.getInt16(offset, false);\n  var fraction = dataView.getUint16(offset + 2, false);\n  return decimal + fraction / 65535;\n} // Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\n\n\nfunction getTag(dataView, offset) {\n  var tag = '';\n\n  for (var i = offset; i < offset + 4; i += 1) {\n    tag += String.fromCharCode(dataView.getInt8(i));\n  }\n\n  return tag;\n} // Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\n\n\nfunction getOffset(dataView, offset, offSize) {\n  var v = 0;\n\n  for (var i = 0; i < offSize; i += 1) {\n    v <<= 8;\n    v += dataView.getUint8(offset + i);\n  }\n\n  return v;\n} // Retrieve a number of bytes from start offset to the end offset from the DataView.\n\n\nfunction getBytes(dataView, startOffset, endOffset) {\n  var bytes = [];\n\n  for (var i = startOffset; i < endOffset; i += 1) {\n    bytes.push(dataView.getUint8(i));\n  }\n\n  return bytes;\n} // Convert the list of bytes to a string.\n\n\nfunction bytesToString(bytes) {\n  var s = '';\n\n  for (var i = 0; i < bytes.length; i += 1) {\n    s += String.fromCharCode(bytes[i]);\n  }\n\n  return s;\n}\n\nvar typeOffsets = {\n  byte: 1,\n  uShort: 2,\n  short: 2,\n  uLong: 4,\n  fixed: 4,\n  longDateTime: 8,\n  tag: 4\n}; // A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\n\nfunction Parser(data, offset) {\n  this.data = data;\n  this.offset = offset;\n  this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function () {\n  var v = this.data.getUint8(this.offset + this.relativeOffset);\n  this.relativeOffset += 1;\n  return v;\n};\n\nParser.prototype.parseChar = function () {\n  var v = this.data.getInt8(this.offset + this.relativeOffset);\n  this.relativeOffset += 1;\n  return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function () {\n  var v = this.data.getUint16(this.offset + this.relativeOffset);\n  this.relativeOffset += 2;\n  return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function () {\n  var v = this.data.getInt16(this.offset + this.relativeOffset);\n  this.relativeOffset += 2;\n  return v;\n};\n\nParser.prototype.parseF2Dot14 = function () {\n  var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n  this.relativeOffset += 2;\n  return v;\n};\n\nParser.prototype.parseULong = function () {\n  var v = getULong(this.data, this.offset + this.relativeOffset);\n  this.relativeOffset += 4;\n  return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function () {\n  var v = getFixed(this.data, this.offset + this.relativeOffset);\n  this.relativeOffset += 4;\n  return v;\n};\n\nParser.prototype.parseString = function (length) {\n  var dataView = this.data;\n  var offset = this.offset + this.relativeOffset;\n  var string = '';\n  this.relativeOffset += length;\n\n  for (var i = 0; i < length; i++) {\n    string += String.fromCharCode(dataView.getUint8(offset + i));\n  }\n\n  return string;\n};\n\nParser.prototype.parseTag = function () {\n  return this.parseString(4);\n}; // LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\n\n\nParser.prototype.parseLongDateTime = function () {\n  var v = getULong(this.data, this.offset + this.relativeOffset + 4); // Subtract seconds between 01/01/1904 and 01/01/1970\n  // to convert Apple Mac timestamp to Standard Unix timestamp\n\n  v -= 2082844800;\n  this.relativeOffset += 8;\n  return v;\n};\n\nParser.prototype.parseVersion = function (minorBase) {\n  var major = getUShort(this.data, this.offset + this.relativeOffset); // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n  // Default returns the correct number if minor = 0xN000 where N is 0-9\n  // Set minorBase to 1 for tables that use minor = N where N is 0-9\n\n  var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n  this.relativeOffset += 4;\n  if (minorBase === undefined) minorBase = 0x1000;\n  return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function (type, amount) {\n  if (amount === undefined) {\n    amount = 1;\n  }\n\n  this.relativeOffset += typeOffsets[type] * amount;\n}; ///// Parsing lists and records ///////////////////////////////\n// Parse a list of 32 bit unsigned integers.\n\n\nParser.prototype.parseULongList = function (count) {\n  if (count === undefined) {\n    count = this.parseULong();\n  }\n\n  var offsets = new Array(count);\n  var dataView = this.data;\n  var offset = this.offset + this.relativeOffset;\n\n  for (var i = 0; i < count; i++) {\n    offsets[i] = dataView.getUint32(offset);\n    offset += 4;\n  }\n\n  this.relativeOffset += count * 4;\n  return offsets;\n}; // Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\n\n\nParser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function (count) {\n  if (count === undefined) {\n    count = this.parseUShort();\n  }\n\n  var offsets = new Array(count);\n  var dataView = this.data;\n  var offset = this.offset + this.relativeOffset;\n\n  for (var i = 0; i < count; i++) {\n    offsets[i] = dataView.getUint16(offset);\n    offset += 2;\n  }\n\n  this.relativeOffset += count * 2;\n  return offsets;\n}; // Parses a list of 16 bit signed integers.\n\n\nParser.prototype.parseShortList = function (count) {\n  var list = new Array(count);\n  var dataView = this.data;\n  var offset = this.offset + this.relativeOffset;\n\n  for (var i = 0; i < count; i++) {\n    list[i] = dataView.getInt16(offset);\n    offset += 2;\n  }\n\n  this.relativeOffset += count * 2;\n  return list;\n}; // Parses a list of bytes.\n\n\nParser.prototype.parseByteList = function (count) {\n  var list = new Array(count);\n  var dataView = this.data;\n  var offset = this.offset + this.relativeOffset;\n\n  for (var i = 0; i < count; i++) {\n    list[i] = dataView.getUint8(offset++);\n  }\n\n  this.relativeOffset += count;\n  return list;\n};\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\n\n\nParser.prototype.parseList = function (count, itemCallback) {\n  if (!itemCallback) {\n    itemCallback = count;\n    count = this.parseUShort();\n  }\n\n  var list = new Array(count);\n\n  for (var i = 0; i < count; i++) {\n    list[i] = itemCallback.call(this);\n  }\n\n  return list;\n};\n\nParser.prototype.parseList32 = function (count, itemCallback) {\n  if (!itemCallback) {\n    itemCallback = count;\n    count = this.parseULong();\n  }\n\n  var list = new Array(count);\n\n  for (var i = 0; i < count; i++) {\n    list[i] = itemCallback.call(this);\n  }\n\n  return list;\n};\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\n\n\nParser.prototype.parseRecordList = function (count, recordDescription) {\n  // If the count argument is absent, read it in the stream.\n  if (!recordDescription) {\n    recordDescription = count;\n    count = this.parseUShort();\n  }\n\n  var records = new Array(count);\n  var fields = Object.keys(recordDescription);\n\n  for (var i = 0; i < count; i++) {\n    var rec = {};\n\n    for (var j = 0; j < fields.length; j++) {\n      var fieldName = fields[j];\n      var fieldType = recordDescription[fieldName];\n      rec[fieldName] = fieldType.call(this);\n    }\n\n    records[i] = rec;\n  }\n\n  return records;\n};\n\nParser.prototype.parseRecordList32 = function (count, recordDescription) {\n  // If the count argument is absent, read it in the stream.\n  if (!recordDescription) {\n    recordDescription = count;\n    count = this.parseULong();\n  }\n\n  var records = new Array(count);\n  var fields = Object.keys(recordDescription);\n\n  for (var i = 0; i < count; i++) {\n    var rec = {};\n\n    for (var j = 0; j < fields.length; j++) {\n      var fieldName = fields[j];\n      var fieldType = recordDescription[fieldName];\n      rec[fieldName] = fieldType.call(this);\n    }\n\n    records[i] = rec;\n  }\n\n  return records;\n}; // Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n\n\nParser.prototype.parseStruct = function (description) {\n  if (typeof description === 'function') {\n    return description.call(this);\n  } else {\n    var fields = Object.keys(description);\n    var struct = {};\n\n    for (var j = 0; j < fields.length; j++) {\n      var fieldName = fields[j];\n      var fieldType = description[fieldName];\n      struct[fieldName] = fieldType.call(this);\n    }\n\n    return struct;\n  }\n};\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\n\n\nParser.prototype.parseValueRecord = function (valueFormat) {\n  if (valueFormat === undefined) {\n    valueFormat = this.parseUShort();\n  }\n\n  if (valueFormat === 0) {\n    // valueFormat2 in kerning pairs is most often 0\n    // in this case return undefined instead of an empty object, to save space\n    return;\n  }\n\n  var valueRecord = {};\n\n  if (valueFormat & 0x0001) {\n    valueRecord.xPlacement = this.parseShort();\n  }\n\n  if (valueFormat & 0x0002) {\n    valueRecord.yPlacement = this.parseShort();\n  }\n\n  if (valueFormat & 0x0004) {\n    valueRecord.xAdvance = this.parseShort();\n  }\n\n  if (valueFormat & 0x0008) {\n    valueRecord.yAdvance = this.parseShort();\n  } // Device table (non-variable font) / VariationIndex table (variable font) not supported\n  // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n\n\n  if (valueFormat & 0x0010) {\n    valueRecord.xPlaDevice = undefined;\n    this.parseShort();\n  }\n\n  if (valueFormat & 0x0020) {\n    valueRecord.yPlaDevice = undefined;\n    this.parseShort();\n  }\n\n  if (valueFormat & 0x0040) {\n    valueRecord.xAdvDevice = undefined;\n    this.parseShort();\n  }\n\n  if (valueFormat & 0x0080) {\n    valueRecord.yAdvDevice = undefined;\n    this.parseShort();\n  }\n\n  return valueRecord;\n};\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\n\n\nParser.prototype.parseValueRecordList = function () {\n  var valueFormat = this.parseUShort();\n  var valueCount = this.parseUShort();\n  var values = new Array(valueCount);\n\n  for (var i = 0; i < valueCount; i++) {\n    values[i] = this.parseValueRecord(valueFormat);\n  }\n\n  return values;\n};\n\nParser.prototype.parsePointer = function (description) {\n  var structOffset = this.parseOffset16();\n\n  if (structOffset > 0) {\n    // NULL offset => return undefined\n    return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n  }\n\n  return undefined;\n};\n\nParser.prototype.parsePointer32 = function (description) {\n  var structOffset = this.parseOffset32();\n\n  if (structOffset > 0) {\n    // NULL offset => return undefined\n    return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n  }\n\n  return undefined;\n};\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\n\n\nParser.prototype.parseListOfLists = function (itemCallback) {\n  var offsets = this.parseOffset16List();\n  var count = offsets.length;\n  var relativeOffset = this.relativeOffset;\n  var list = new Array(count);\n\n  for (var i = 0; i < count; i++) {\n    var start = offsets[i];\n\n    if (start === 0) {\n      // NULL offset\n      // Add i as owned property to list. Convenient with assert.\n      list[i] = undefined;\n      continue;\n    }\n\n    this.relativeOffset = start;\n\n    if (itemCallback) {\n      var subOffsets = this.parseOffset16List();\n      var subList = new Array(subOffsets.length);\n\n      for (var j = 0; j < subOffsets.length; j++) {\n        this.relativeOffset = start + subOffsets[j];\n        subList[j] = itemCallback.call(this);\n      }\n\n      list[i] = subList;\n    } else {\n      list[i] = this.parseUShortList();\n    }\n  }\n\n  this.relativeOffset = relativeOffset;\n  return list;\n}; ///// Complex tables parsing //////////////////////////////////\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\n\n\nParser.prototype.parseCoverage = function () {\n  var startOffset = this.offset + this.relativeOffset;\n  var format = this.parseUShort();\n  var count = this.parseUShort();\n\n  if (format === 1) {\n    return {\n      format: 1,\n      glyphs: this.parseUShortList(count)\n    };\n  } else if (format === 2) {\n    var ranges = new Array(count);\n\n    for (var i = 0; i < count; i++) {\n      ranges[i] = {\n        start: this.parseUShort(),\n        end: this.parseUShort(),\n        index: this.parseUShort()\n      };\n    }\n\n    return {\n      format: 2,\n      ranges: ranges\n    };\n  }\n\n  throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n}; // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\n\nParser.prototype.parseClassDef = function () {\n  var startOffset = this.offset + this.relativeOffset;\n  var format = this.parseUShort();\n\n  if (format === 1) {\n    return {\n      format: 1,\n      startGlyph: this.parseUShort(),\n      classes: this.parseUShortList()\n    };\n  } else if (format === 2) {\n    return {\n      format: 2,\n      ranges: this.parseRecordList({\n        start: Parser.uShort,\n        end: Parser.uShort,\n        classId: Parser.uShort\n      })\n    };\n  }\n\n  throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n}; ///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\n\nParser.list = function (count, itemCallback) {\n  return function () {\n    return this.parseList(count, itemCallback);\n  };\n};\n\nParser.list32 = function (count, itemCallback) {\n  return function () {\n    return this.parseList32(count, itemCallback);\n  };\n};\n\nParser.recordList = function (count, recordDescription) {\n  return function () {\n    return this.parseRecordList(count, recordDescription);\n  };\n};\n\nParser.recordList32 = function (count, recordDescription) {\n  return function () {\n    return this.parseRecordList32(count, recordDescription);\n  };\n};\n\nParser.pointer = function (description) {\n  return function () {\n    return this.parsePointer(description);\n  };\n};\n\nParser.pointer32 = function (description) {\n  return function () {\n    return this.parsePointer32(description);\n  };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef; ///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n  reserved: Parser.uShort,\n  reqFeatureIndex: Parser.uShort,\n  featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function () {\n  return this.parsePointer(Parser.recordList({\n    tag: Parser.tag,\n    script: Parser.pointer({\n      defaultLangSys: Parser.pointer(langSysTable),\n      langSysRecords: Parser.recordList({\n        tag: Parser.tag,\n        langSys: Parser.pointer(langSysTable)\n      })\n    })\n  })) || [];\n};\n\nParser.prototype.parseFeatureList = function () {\n  return this.parsePointer(Parser.recordList({\n    tag: Parser.tag,\n    feature: Parser.pointer({\n      featureParams: Parser.offset16,\n      lookupListIndexes: Parser.uShortList\n    })\n  })) || [];\n};\n\nParser.prototype.parseLookupList = function (lookupTableParsers) {\n  return this.parsePointer(Parser.list(Parser.pointer(function () {\n    var lookupType = this.parseUShort();\n    check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n    var lookupFlag = this.parseUShort();\n    var useMarkFilteringSet = lookupFlag & 0x10;\n    return {\n      lookupType: lookupType,\n      lookupFlag: lookupFlag,\n      subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n      markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n    };\n  }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function () {\n  return this.parsePointer32(function () {\n    var majorVersion = this.parseUShort();\n    var minorVersion = this.parseUShort();\n    check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n    var featureVariations = this.parseRecordList32({\n      conditionSetOffset: Parser.offset32,\n      featureTableSubstitutionOffset: Parser.offset32\n    });\n    return featureVariations;\n  }) || [];\n};\n\nexport default {\n  getByte: getByte,\n  getCard8: getByte,\n  getUShort: getUShort,\n  getCard16: getUShort,\n  getShort: getShort,\n  getULong: getULong,\n  getFixed: getFixed,\n  getTag: getTag,\n  getOffset: getOffset,\n  getBytes: getBytes,\n  bytesToString: bytesToString,\n  Parser: Parser\n};\nexport { Parser };","map":null,"metadata":{},"sourceType":"module"}