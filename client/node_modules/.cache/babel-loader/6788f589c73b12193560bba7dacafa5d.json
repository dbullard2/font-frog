{"ast":null,"code":"// The Layout object is the prototype of Substitution objects, and provides\n// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)\nimport check from './check';\n\nfunction searchTag(arr, tag) {\n  /* jshint bitwise: false */\n  var imin = 0;\n  var imax = arr.length - 1;\n\n  while (imin <= imax) {\n    var imid = imin + imax >>> 1;\n    var val = arr[imid].tag;\n\n    if (val === tag) {\n      return imid;\n    } else if (val < tag) {\n      imin = imid + 1;\n    } else {\n      imax = imid - 1;\n    }\n  } // Not found: return -1-insertion point\n\n\n  return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n  /* jshint bitwise: false */\n  var imin = 0;\n  var imax = arr.length - 1;\n\n  while (imin <= imax) {\n    var imid = imin + imax >>> 1;\n    var val = arr[imid];\n\n    if (val === value) {\n      return imid;\n    } else if (val < value) {\n      imin = imid + 1;\n    } else {\n      imax = imid - 1;\n    }\n  } // Not found: return -1-insertion point\n\n\n  return -imin - 1;\n} // binary search in a list of ranges (coverage, class definition)\n\n\nfunction searchRange(ranges, value) {\n  // jshint bitwise: false\n  var range;\n  var imin = 0;\n  var imax = ranges.length - 1;\n\n  while (imin <= imax) {\n    var imid = imin + imax >>> 1;\n    range = ranges[imid];\n    var start = range.start;\n\n    if (start === value) {\n      return range;\n    } else if (start < value) {\n      imin = imid + 1;\n    } else {\n      imax = imid - 1;\n    }\n  }\n\n  if (imin > 0) {\n    range = ranges[imin - 1];\n    if (value > range.end) return 0;\n    return range;\n  }\n}\n/**\n * @exports opentype.Layout\n * @class\n */\n\n\nfunction Layout(font, tableName) {\n  this.font = font;\n  this.tableName = tableName;\n}\n\nLayout.prototype = {\n  /**\n   * Binary search an object by \"tag\" property\n   * @instance\n   * @function searchTag\n   * @memberof opentype.Layout\n   * @param  {Array} arr\n   * @param  {string} tag\n   * @return {number}\n   */\n  searchTag: searchTag,\n\n  /**\n   * Binary search in a list of numbers\n   * @instance\n   * @function binSearch\n   * @memberof opentype.Layout\n   * @param  {Array} arr\n   * @param  {number} value\n   * @return {number}\n   */\n  binSearch: binSearch,\n\n  /**\n   * Get or create the Layout table (GSUB, GPOS etc).\n   * @param  {boolean} create - Whether to create a new one.\n   * @return {Object} The GSUB or GPOS table.\n   */\n  getTable: function getTable(create) {\n    var layout = this.font.tables[this.tableName];\n\n    if (!layout && create) {\n      layout = this.font.tables[this.tableName] = this.createDefaultTable();\n    }\n\n    return layout;\n  },\n\n  /**\n   * Returns all scripts in the substitution table.\n   * @instance\n   * @return {Array}\n   */\n  getScriptNames: function getScriptNames() {\n    var layout = this.getTable();\n\n    if (!layout) {\n      return [];\n    }\n\n    return layout.scripts.map(function (script) {\n      return script.tag;\n    });\n  },\n\n  /**\n   * Returns the best bet for a script name.\n   * Returns 'DFLT' if it exists.\n   * If not, returns 'latn' if it exists.\n   * If neither exist, returns undefined.\n   */\n  getDefaultScriptName: function getDefaultScriptName() {\n    var layout = this.getTable();\n\n    if (!layout) {\n      return;\n    }\n\n    var hasLatn = false;\n\n    for (var i = 0; i < layout.scripts.length; i++) {\n      var name = layout.scripts[i].tag;\n      if (name === 'DFLT') return name;\n      if (name === 'latn') hasLatn = true;\n    }\n\n    if (hasLatn) return 'latn';\n  },\n\n  /**\n   * Returns all LangSysRecords in the given script.\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n   * @return {Object} An object with tag and script properties.\n   */\n  getScriptTable: function getScriptTable(script, create) {\n    var layout = this.getTable(create);\n\n    if (layout) {\n      script = script || 'DFLT';\n      var scripts = layout.scripts;\n      var pos = searchTag(layout.scripts, script);\n\n      if (pos >= 0) {\n        return scripts[pos].script;\n      } else if (create) {\n        var scr = {\n          tag: script,\n          script: {\n            defaultLangSys: {\n              reserved: 0,\n              reqFeatureIndex: 0xffff,\n              featureIndexes: []\n            },\n            langSysRecords: []\n          }\n        };\n        scripts.splice(-1 - pos, 0, scr);\n        return scr.script;\n      }\n    }\n  },\n\n  /**\n   * Returns a language system table\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dlft']\n   * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n   * @return {Object}\n   */\n  getLangSysTable: function getLangSysTable(script, language, create) {\n    var scriptTable = this.getScriptTable(script, create);\n\n    if (scriptTable) {\n      if (!language || language === 'dflt' || language === 'DFLT') {\n        return scriptTable.defaultLangSys;\n      }\n\n      var pos = searchTag(scriptTable.langSysRecords, language);\n\n      if (pos >= 0) {\n        return scriptTable.langSysRecords[pos].langSys;\n      } else if (create) {\n        var langSysRecord = {\n          tag: language,\n          langSys: {\n            reserved: 0,\n            reqFeatureIndex: 0xffff,\n            featureIndexes: []\n          }\n        };\n        scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n        return langSysRecord.langSys;\n      }\n    }\n  },\n\n  /**\n   * Get a specific feature table.\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dlft']\n   * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n   * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n   * @return {Object}\n   */\n  getFeatureTable: function getFeatureTable(script, language, feature, create) {\n    var langSysTable = this.getLangSysTable(script, language, create);\n\n    if (langSysTable) {\n      var featureRecord;\n      var featIndexes = langSysTable.featureIndexes;\n      var allFeatures = this.font.tables[this.tableName].features; // The FeatureIndex array of indices is in arbitrary order,\n      // even if allFeatures is sorted alphabetically by feature tag.\n\n      for (var i = 0; i < featIndexes.length; i++) {\n        featureRecord = allFeatures[featIndexes[i]];\n\n        if (featureRecord.tag === feature) {\n          return featureRecord.feature;\n        }\n      }\n\n      if (create) {\n        var index = allFeatures.length; // Automatic ordering of features would require to shift feature indexes in the script list.\n\n        check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n        featureRecord = {\n          tag: feature,\n          feature: {\n            params: 0,\n            lookupListIndexes: []\n          }\n        };\n        allFeatures.push(featureRecord);\n        featIndexes.push(index);\n        return featureRecord.feature;\n      }\n    }\n  },\n\n  /**\n   * Get the lookup tables of a given type for a script/language/feature.\n   * @instance\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dlft']\n   * @param {string} feature - 4-letter feature code\n   * @param {number} lookupType - 1 to 9\n   * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n   * @return {Object[]}\n   */\n  getLookupTables: function getLookupTables(script, language, feature, lookupType, create) {\n    var featureTable = this.getFeatureTable(script, language, feature, create);\n    var tables = [];\n\n    if (featureTable) {\n      var lookupTable;\n      var lookupListIndexes = featureTable.lookupListIndexes;\n      var allLookups = this.font.tables[this.tableName].lookups; // lookupListIndexes are in no particular order, so use naive search.\n\n      for (var i = 0; i < lookupListIndexes.length; i++) {\n        lookupTable = allLookups[lookupListIndexes[i]];\n\n        if (lookupTable.lookupType === lookupType) {\n          tables.push(lookupTable);\n        }\n      }\n\n      if (tables.length === 0 && create) {\n        lookupTable = {\n          lookupType: lookupType,\n          lookupFlag: 0,\n          subtables: [],\n          markFilteringSet: undefined\n        };\n        var index = allLookups.length;\n        allLookups.push(lookupTable);\n        lookupListIndexes.push(index);\n        return [lookupTable];\n      }\n    }\n\n    return tables;\n  },\n\n  /**\n   * Find a glyph in a class definition table\n   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n   * @param {object} classDefTable - an OpenType Layout class definition table\n   * @param {number} glyphIndex - the index of the glyph to find\n   * @returns {number} -1 if not found\n   */\n  getGlyphClass: function getGlyphClass(classDefTable, glyphIndex) {\n    switch (classDefTable.format) {\n      case 1:\n        if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n          return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n        }\n\n        return 0;\n\n      case 2:\n        var range = searchRange(classDefTable.ranges, glyphIndex);\n        return range ? range.classId : 0;\n    }\n  },\n\n  /**\n   * Find a glyph in a coverage table\n   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n   * @param {object} coverageTable - an OpenType Layout coverage table\n   * @param {number} glyphIndex - the index of the glyph to find\n   * @returns {number} -1 if not found\n   */\n  getCoverageIndex: function getCoverageIndex(coverageTable, glyphIndex) {\n    switch (coverageTable.format) {\n      case 1:\n        var index = binSearch(coverageTable.glyphs, glyphIndex);\n        return index >= 0 ? index : -1;\n\n      case 2:\n        var range = searchRange(coverageTable.ranges, glyphIndex);\n        return range ? range.index + glyphIndex - range.start : -1;\n    }\n  },\n\n  /**\n   * Returns the list of glyph indexes of a coverage table.\n   * Format 1: the list is stored raw\n   * Format 2: compact list as range records.\n   * @instance\n   * @param  {Object} coverageTable\n   * @return {Array}\n   */\n  expandCoverage: function expandCoverage(coverageTable) {\n    if (coverageTable.format === 1) {\n      return coverageTable.glyphs;\n    } else {\n      var glyphs = [];\n      var ranges = coverageTable.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        var start = range.start;\n        var end = range.end;\n\n        for (var j = start; j <= end; j++) {\n          glyphs.push(j);\n        }\n      }\n\n      return glyphs;\n    }\n  }\n};\nexport default Layout;","map":null,"metadata":{},"sourceType":"module"}