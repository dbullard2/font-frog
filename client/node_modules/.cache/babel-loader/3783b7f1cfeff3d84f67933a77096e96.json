{"ast":null,"code":"// Geometric objects\nimport BoundingBox from './bbox';\n/**\n * A b√©zier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\n\nfunction Path() {\n  this.commands = [];\n  this.fill = 'black';\n  this.stroke = null;\n  this.strokeWidth = 1;\n}\n/**\n * @param  {number} x\n * @param  {number} y\n */\n\n\nPath.prototype.moveTo = function (x, y) {\n  this.commands.push({\n    type: 'M',\n    x: x,\n    y: y\n  });\n};\n/**\n * @param  {number} x\n * @param  {number} y\n */\n\n\nPath.prototype.lineTo = function (x, y) {\n  this.commands.push({\n    type: 'L',\n    x: x,\n    y: y\n  });\n};\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\n\n\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {\n  this.commands.push({\n    type: 'C',\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2,\n    x: x,\n    y: y\n  });\n};\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {\n  this.commands.push({\n    type: 'Q',\n    x1: x1,\n    y1: y1,\n    x: x,\n    y: y\n  });\n};\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\n\n\nPath.prototype.close = Path.prototype.closePath = function () {\n  this.commands.push({\n    type: 'Z'\n  });\n};\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\n\n\nPath.prototype.extend = function (pathOrCommands) {\n  if (pathOrCommands.commands) {\n    pathOrCommands = pathOrCommands.commands;\n  } else if (pathOrCommands instanceof BoundingBox) {\n    var box = pathOrCommands;\n    this.moveTo(box.x1, box.y1);\n    this.lineTo(box.x2, box.y1);\n    this.lineTo(box.x2, box.y2);\n    this.lineTo(box.x1, box.y2);\n    this.close();\n    return;\n  }\n\n  Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n/**\n * Calculate the bounding box of the path.\n * @returns {opentype.BoundingBox}\n */\n\n\nPath.prototype.getBoundingBox = function () {\n  var box = new BoundingBox();\n  var startX = 0;\n  var startY = 0;\n  var prevX = 0;\n  var prevY = 0;\n\n  for (var i = 0; i < this.commands.length; i++) {\n    var cmd = this.commands[i];\n\n    switch (cmd.type) {\n      case 'M':\n        box.addPoint(cmd.x, cmd.y);\n        startX = prevX = cmd.x;\n        startY = prevY = cmd.y;\n        break;\n\n      case 'L':\n        box.addPoint(cmd.x, cmd.y);\n        prevX = cmd.x;\n        prevY = cmd.y;\n        break;\n\n      case 'Q':\n        box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n        prevX = cmd.x;\n        prevY = cmd.y;\n        break;\n\n      case 'C':\n        box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        prevX = cmd.x;\n        prevY = cmd.y;\n        break;\n\n      case 'Z':\n        prevX = startX;\n        prevY = startY;\n        break;\n\n      default:\n        throw new Error('Unexpected path command ' + cmd.type);\n    }\n  }\n\n  if (box.isEmpty()) {\n    box.addPoint(0, 0);\n  }\n\n  return box;\n};\n/**\n * Draw the path to a 2D context.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n */\n\n\nPath.prototype.draw = function (ctx) {\n  ctx.beginPath();\n\n  for (var i = 0; i < this.commands.length; i += 1) {\n    var cmd = this.commands[i];\n\n    if (cmd.type === 'M') {\n      ctx.moveTo(cmd.x, cmd.y);\n    } else if (cmd.type === 'L') {\n      ctx.lineTo(cmd.x, cmd.y);\n    } else if (cmd.type === 'C') {\n      ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n    } else if (cmd.type === 'Q') {\n      ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n    } else if (cmd.type === 'Z') {\n      ctx.closePath();\n    }\n  }\n\n  if (this.fill) {\n    ctx.fillStyle = this.fill;\n    ctx.fill();\n  }\n\n  if (this.stroke) {\n    ctx.strokeStyle = this.stroke;\n    ctx.lineWidth = this.strokeWidth;\n    ctx.stroke();\n  }\n};\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\n\n\nPath.prototype.toPathData = function (decimalPlaces) {\n  decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n  function floatToString(v) {\n    if (Math.round(v) === v) {\n      return '' + Math.round(v);\n    } else {\n      return v.toFixed(decimalPlaces);\n    }\n  }\n\n  function packValues() {\n    var s = '';\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      var v = arguments[i];\n\n      if (v >= 0 && i > 0) {\n        s += ' ';\n      }\n\n      s += floatToString(v);\n    }\n\n    return s;\n  }\n\n  var d = '';\n\n  for (var i = 0; i < this.commands.length; i += 1) {\n    var cmd = this.commands[i];\n\n    if (cmd.type === 'M') {\n      d += 'M' + packValues(cmd.x, cmd.y);\n    } else if (cmd.type === 'L') {\n      d += 'L' + packValues(cmd.x, cmd.y);\n    } else if (cmd.type === 'C') {\n      d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n    } else if (cmd.type === 'Q') {\n      d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n    } else if (cmd.type === 'Z') {\n      d += 'Z';\n    }\n  }\n\n  return d;\n};\n/**\n * Convert the path to an SVG <path> element, as a string.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\n\n\nPath.prototype.toSVG = function (decimalPlaces) {\n  var svg = '<path d=\"';\n  svg += this.toPathData(decimalPlaces);\n  svg += '\"';\n\n  if (this.fill && this.fill !== 'black') {\n    if (this.fill === null) {\n      svg += ' fill=\"none\"';\n    } else {\n      svg += ' fill=\"' + this.fill + '\"';\n    }\n  }\n\n  if (this.stroke) {\n    svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n  }\n\n  svg += '/>';\n  return svg;\n};\n/**\n * Convert the path to a DOM element.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {SVGPathElement}\n */\n\n\nPath.prototype.toDOMElement = function (decimalPlaces) {\n  var temporaryPath = this.toPathData(decimalPlaces);\n  var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n  newPath.setAttribute('d', temporaryPath);\n  return newPath;\n};\n\nexport default Path;","map":null,"metadata":{},"sourceType":"module"}