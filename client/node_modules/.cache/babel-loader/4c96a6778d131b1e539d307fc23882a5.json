{"ast":null,"code":"// The `CFF` table contains the glyph outlines in PostScript format.\n// https://www.microsoft.com/typography/OTSPEC/cff.htm\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf\nimport { CffEncoding, cffStandardEncoding, cffExpertEncoding, cffStandardStrings } from '../encoding';\nimport glyphset from '../glyphset';\nimport parse from '../parse';\nimport Path from '../path';\nimport table from '../table'; // Custom equals function that can also check lists.\n\nfunction equals(a, b) {\n  if (a === b) {\n    return true;\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i += 1) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n} // Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\n\n\nfunction calcCFFSubroutineBias(subrs) {\n  var bias;\n\n  if (subrs.length < 1240) {\n    bias = 107;\n  } else if (subrs.length < 33900) {\n    bias = 1131;\n  } else {\n    bias = 32768;\n  }\n\n  return bias;\n} // Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\n\n\nfunction parseCFFIndex(data, start, conversionFn) {\n  var offsets = [];\n  var objects = [];\n  var count = parse.getCard16(data, start);\n  var objectOffset;\n  var endOffset;\n\n  if (count !== 0) {\n    var offsetSize = parse.getByte(data, start + 2);\n    objectOffset = start + (count + 1) * offsetSize + 2;\n    var pos = start + 3;\n\n    for (var i = 0; i < count + 1; i += 1) {\n      offsets.push(parse.getOffset(data, pos, offsetSize));\n      pos += offsetSize;\n    } // The total size of the index array is 4 header bytes + the value of the last offset.\n\n\n    endOffset = objectOffset + offsets[count];\n  } else {\n    endOffset = start + 2;\n  }\n\n  for (var _i = 0; _i < offsets.length - 1; _i += 1) {\n    var value = parse.getBytes(data, objectOffset + offsets[_i], objectOffset + offsets[_i + 1]);\n\n    if (conversionFn) {\n      value = conversionFn(value);\n    }\n\n    objects.push(value);\n  }\n\n  return {\n    objects: objects,\n    startOffset: start,\n    endOffset: endOffset\n  };\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n  var offsets = [];\n  var count = parse.getCard16(data, start);\n  var objectOffset;\n  var endOffset;\n\n  if (count !== 0) {\n    var offsetSize = parse.getByte(data, start + 2);\n    objectOffset = start + (count + 1) * offsetSize + 2;\n    var pos = start + 3;\n\n    for (var i = 0; i < count + 1; i += 1) {\n      offsets.push(parse.getOffset(data, pos, offsetSize));\n      pos += offsetSize;\n    } // The total size of the index array is 4 header bytes + the value of the last offset.\n\n\n    endOffset = objectOffset + offsets[count];\n  } else {\n    endOffset = start + 2;\n  }\n\n  return {\n    offsets: offsets,\n    startOffset: start,\n    endOffset: endOffset\n  };\n}\n\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n  var count = parse.getCard16(data, start);\n  var objectOffset = 0;\n\n  if (count !== 0) {\n    var offsetSize = parse.getByte(data, start + 2);\n    objectOffset = start + (count + 1) * offsetSize + 2;\n  }\n\n  var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n\n  if (conversionFn) {\n    value = conversionFn(value);\n  }\n\n  return value;\n} // Parse a `CFF` DICT real value.\n\n\nfunction parseFloatOperand(parser) {\n  var s = '';\n  var eof = 15;\n  var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n\n  while (true) {\n    var b = parser.parseByte();\n    var n1 = b >> 4;\n    var n2 = b & 15;\n\n    if (n1 === eof) {\n      break;\n    }\n\n    s += lookup[n1];\n\n    if (n2 === eof) {\n      break;\n    }\n\n    s += lookup[n2];\n  }\n\n  return parseFloat(s);\n} // Parse a `CFF` DICT operand.\n\n\nfunction parseOperand(parser, b0) {\n  var b1;\n  var b2;\n  var b3;\n  var b4;\n\n  if (b0 === 28) {\n    b1 = parser.parseByte();\n    b2 = parser.parseByte();\n    return b1 << 8 | b2;\n  }\n\n  if (b0 === 29) {\n    b1 = parser.parseByte();\n    b2 = parser.parseByte();\n    b3 = parser.parseByte();\n    b4 = parser.parseByte();\n    return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n  }\n\n  if (b0 === 30) {\n    return parseFloatOperand(parser);\n  }\n\n  if (b0 >= 32 && b0 <= 246) {\n    return b0 - 139;\n  }\n\n  if (b0 >= 247 && b0 <= 250) {\n    b1 = parser.parseByte();\n    return (b0 - 247) * 256 + b1 + 108;\n  }\n\n  if (b0 >= 251 && b0 <= 254) {\n    b1 = parser.parseByte();\n    return -(b0 - 251) * 256 - b1 - 108;\n  }\n\n  throw new Error('Invalid b0 ' + b0);\n} // Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\n\n\nfunction entriesToObject(entries) {\n  var o = {};\n\n  for (var i = 0; i < entries.length; i += 1) {\n    var key = entries[i][0];\n    var values = entries[i][1];\n    var value = void 0;\n\n    if (values.length === 1) {\n      value = values[0];\n    } else {\n      value = values;\n    }\n\n    if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n      throw new Error('Object ' + o + ' already has key ' + key);\n    }\n\n    o[key] = value;\n  }\n\n  return o;\n} // Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\n\n\nfunction parseCFFDict(data, start, size) {\n  start = start !== undefined ? start : 0;\n  var parser = new parse.Parser(data, start);\n  var entries = [];\n  var operands = [];\n  size = size !== undefined ? size : data.length;\n\n  while (parser.relativeOffset < size) {\n    var op = parser.parseByte(); // The first byte for each dict item distinguishes between operator (key) and operand (value).\n    // Values <= 21 are operators.\n\n    if (op <= 21) {\n      // Two-byte operators have an initial escape byte of 12.\n      if (op === 12) {\n        op = 1200 + parser.parseByte();\n      }\n\n      entries.push([op, operands]);\n      operands = [];\n    } else {\n      // Since the operands (values) come before the operators (keys), we store all operands in a list\n      // until we encounter an operator.\n      operands.push(parseOperand(parser, op));\n    }\n  }\n\n  return entriesToObject(entries);\n} // Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\n\n\nfunction getCFFString(strings, index) {\n  if (index <= 390) {\n    index = cffStandardStrings[index];\n  } else {\n    index = strings[index - 391];\n  }\n\n  return index;\n} // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\n\n\nfunction interpretDict(dict, meta, strings) {\n  var newDict = {};\n  var value; // Because we also want to include missing values, we start out from the meta list\n  // and lookup values in the dict.\n\n  for (var i = 0; i < meta.length; i += 1) {\n    var m = meta[i];\n\n    if (Array.isArray(m.type)) {\n      var values = [];\n      values.length = m.type.length;\n\n      for (var j = 0; j < m.type.length; j++) {\n        value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n\n        if (value === undefined) {\n          value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n        }\n\n        if (m.type[j] === 'SID') {\n          value = getCFFString(strings, value);\n        }\n\n        values[j] = value;\n      }\n\n      newDict[m.name] = values;\n    } else {\n      value = dict[m.op];\n\n      if (value === undefined) {\n        value = m.value !== undefined ? m.value : null;\n      }\n\n      if (m.type === 'SID') {\n        value = getCFFString(strings, value);\n      }\n\n      newDict[m.name] = value;\n    }\n  }\n\n  return newDict;\n} // Parse the CFF header.\n\n\nfunction parseCFFHeader(data, start) {\n  var header = {};\n  header.formatMajor = parse.getCard8(data, start);\n  header.formatMinor = parse.getCard8(data, start + 1);\n  header.size = parse.getCard8(data, start + 2);\n  header.offsetSize = parse.getCard8(data, start + 3);\n  header.startOffset = start;\n  header.endOffset = start + 4;\n  return header;\n}\n\nvar TOP_DICT_META = [{\n  name: 'version',\n  op: 0,\n  type: 'SID'\n}, {\n  name: 'notice',\n  op: 1,\n  type: 'SID'\n}, {\n  name: 'copyright',\n  op: 1200,\n  type: 'SID'\n}, {\n  name: 'fullName',\n  op: 2,\n  type: 'SID'\n}, {\n  name: 'familyName',\n  op: 3,\n  type: 'SID'\n}, {\n  name: 'weight',\n  op: 4,\n  type: 'SID'\n}, {\n  name: 'isFixedPitch',\n  op: 1201,\n  type: 'number',\n  value: 0\n}, {\n  name: 'italicAngle',\n  op: 1202,\n  type: 'number',\n  value: 0\n}, {\n  name: 'underlinePosition',\n  op: 1203,\n  type: 'number',\n  value: -100\n}, {\n  name: 'underlineThickness',\n  op: 1204,\n  type: 'number',\n  value: 50\n}, {\n  name: 'paintType',\n  op: 1205,\n  type: 'number',\n  value: 0\n}, {\n  name: 'charstringType',\n  op: 1206,\n  type: 'number',\n  value: 2\n}, {\n  name: 'fontMatrix',\n  op: 1207,\n  type: ['real', 'real', 'real', 'real', 'real', 'real'],\n  value: [0.001, 0, 0, 0.001, 0, 0]\n}, {\n  name: 'uniqueId',\n  op: 13,\n  type: 'number'\n}, {\n  name: 'fontBBox',\n  op: 5,\n  type: ['number', 'number', 'number', 'number'],\n  value: [0, 0, 0, 0]\n}, {\n  name: 'strokeWidth',\n  op: 1208,\n  type: 'number',\n  value: 0\n}, {\n  name: 'xuid',\n  op: 14,\n  type: [],\n  value: null\n}, {\n  name: 'charset',\n  op: 15,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'encoding',\n  op: 16,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'charStrings',\n  op: 17,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'private',\n  op: 18,\n  type: ['number', 'offset'],\n  value: [0, 0]\n}, {\n  name: 'ros',\n  op: 1230,\n  type: ['SID', 'SID', 'number']\n}, {\n  name: 'cidFontVersion',\n  op: 1231,\n  type: 'number',\n  value: 0\n}, {\n  name: 'cidFontRevision',\n  op: 1232,\n  type: 'number',\n  value: 0\n}, {\n  name: 'cidFontType',\n  op: 1233,\n  type: 'number',\n  value: 0\n}, {\n  name: 'cidCount',\n  op: 1234,\n  type: 'number',\n  value: 8720\n}, {\n  name: 'uidBase',\n  op: 1235,\n  type: 'number'\n}, {\n  name: 'fdArray',\n  op: 1236,\n  type: 'offset'\n}, {\n  name: 'fdSelect',\n  op: 1237,\n  type: 'offset'\n}, {\n  name: 'fontName',\n  op: 1238,\n  type: 'SID'\n}];\nvar PRIVATE_DICT_META = [{\n  name: 'subrs',\n  op: 19,\n  type: 'offset',\n  value: 0\n}, {\n  name: 'defaultWidthX',\n  op: 20,\n  type: 'number',\n  value: 0\n}, {\n  name: 'nominalWidthX',\n  op: 21,\n  type: 'number',\n  value: 0\n}]; // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\n\nfunction parseCFFTopDict(data, strings) {\n  var dict = parseCFFDict(data, 0, data.byteLength);\n  return interpretDict(dict, TOP_DICT_META, strings);\n} // Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\n\n\nfunction parseCFFPrivateDict(data, start, size, strings) {\n  var dict = parseCFFDict(data, start, size);\n  return interpretDict(dict, PRIVATE_DICT_META, strings);\n} // Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\n\n\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n  var topDictArray = [];\n\n  for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n    var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n    var topDict = parseCFFTopDict(topDictData, strings);\n    topDict._subrs = [];\n    topDict._subrsBias = 0;\n    var privateSize = topDict.private[0];\n    var privateOffset = topDict.private[1];\n\n    if (privateSize !== 0 && privateOffset !== 0) {\n      var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n      topDict._defaultWidthX = privateDict.defaultWidthX;\n      topDict._nominalWidthX = privateDict.nominalWidthX;\n\n      if (privateDict.subrs !== 0) {\n        var subrOffset = privateOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset + start);\n        topDict._subrs = subrIndex.objects;\n        topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n      }\n\n      topDict._privateDict = privateDict;\n    }\n\n    topDictArray.push(topDict);\n  }\n\n  return topDictArray;\n} // Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\n\n\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n  var sid;\n  var count;\n  var parser = new parse.Parser(data, start); // The .notdef glyph is not included, so subtract 1.\n\n  nGlyphs -= 1;\n  var charset = ['.notdef'];\n  var format = parser.parseCard8();\n\n  if (format === 0) {\n    for (var i = 0; i < nGlyphs; i += 1) {\n      sid = parser.parseSID();\n      charset.push(getCFFString(strings, sid));\n    }\n  } else if (format === 1) {\n    while (charset.length <= nGlyphs) {\n      sid = parser.parseSID();\n      count = parser.parseCard8();\n\n      for (var _i2 = 0; _i2 <= count; _i2 += 1) {\n        charset.push(getCFFString(strings, sid));\n        sid += 1;\n      }\n    }\n  } else if (format === 2) {\n    while (charset.length <= nGlyphs) {\n      sid = parser.parseSID();\n      count = parser.parseCard16();\n\n      for (var _i3 = 0; _i3 <= count; _i3 += 1) {\n        charset.push(getCFFString(strings, sid));\n        sid += 1;\n      }\n    }\n  } else {\n    throw new Error('Unknown charset format ' + format);\n  }\n\n  return charset;\n} // Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\n\n\nfunction parseCFFEncoding(data, start, charset) {\n  var code;\n  var enc = {};\n  var parser = new parse.Parser(data, start);\n  var format = parser.parseCard8();\n\n  if (format === 0) {\n    var nCodes = parser.parseCard8();\n\n    for (var i = 0; i < nCodes; i += 1) {\n      code = parser.parseCard8();\n      enc[code] = i;\n    }\n  } else if (format === 1) {\n    var nRanges = parser.parseCard8();\n    code = 1;\n\n    for (var _i4 = 0; _i4 < nRanges; _i4 += 1) {\n      var first = parser.parseCard8();\n      var nLeft = parser.parseCard8();\n\n      for (var j = first; j <= first + nLeft; j += 1) {\n        enc[j] = code;\n        code += 1;\n      }\n    }\n  } else {\n    throw new Error('Unknown encoding format ' + format);\n  }\n\n  return new CffEncoding(enc, charset);\n} // Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\n\n\nfunction parseCFFCharstring(font, glyph, code) {\n  var c1x;\n  var c1y;\n  var c2x;\n  var c2y;\n  var p = new Path();\n  var stack = [];\n  var nStems = 0;\n  var haveWidth = false;\n  var open = false;\n  var x = 0;\n  var y = 0;\n  var subrs;\n  var subrsBias;\n  var defaultWidthX;\n  var nominalWidthX;\n\n  if (font.isCIDFont) {\n    var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n    var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n    subrs = fdDict._subrs;\n    subrsBias = fdDict._subrsBias;\n    defaultWidthX = fdDict._defaultWidthX;\n    nominalWidthX = fdDict._nominalWidthX;\n  } else {\n    subrs = font.tables.cff.topDict._subrs;\n    subrsBias = font.tables.cff.topDict._subrsBias;\n    defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n    nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n  }\n\n  var width = defaultWidthX;\n\n  function newContour(x, y) {\n    if (open) {\n      p.closePath();\n    }\n\n    p.moveTo(x, y);\n    open = true;\n  }\n\n  function parseStems() {\n    var hasWidthArg; // The number of stem operators on the stack is always even.\n    // If the value is uneven, that means a width is specified.\n\n    hasWidthArg = stack.length % 2 !== 0;\n\n    if (hasWidthArg && !haveWidth) {\n      width = stack.shift() + nominalWidthX;\n    }\n\n    nStems += stack.length >> 1;\n    stack.length = 0;\n    haveWidth = true;\n  }\n\n  function parse(code) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    var codeIndex;\n    var subrCode;\n    var jpx;\n    var jpy;\n    var c3x;\n    var c3y;\n    var c4x;\n    var c4y;\n    var i = 0;\n\n    while (i < code.length) {\n      var v = code[i];\n      i += 1;\n\n      switch (v) {\n        case 1:\n          // hstem\n          parseStems();\n          break;\n\n        case 3:\n          // vstem\n          parseStems();\n          break;\n\n        case 4:\n          // vmoveto\n          if (stack.length > 1 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n\n          y += stack.pop();\n          newContour(x, y);\n          break;\n\n        case 5:\n          // rlineto\n          while (stack.length > 0) {\n            x += stack.shift();\n            y += stack.shift();\n            p.lineTo(x, y);\n          }\n\n          break;\n\n        case 6:\n          // hlineto\n          while (stack.length > 0) {\n            x += stack.shift();\n            p.lineTo(x, y);\n\n            if (stack.length === 0) {\n              break;\n            }\n\n            y += stack.shift();\n            p.lineTo(x, y);\n          }\n\n          break;\n\n        case 7:\n          // vlineto\n          while (stack.length > 0) {\n            y += stack.shift();\n            p.lineTo(x, y);\n\n            if (stack.length === 0) {\n              break;\n            }\n\n            x += stack.shift();\n            p.lineTo(x, y);\n          }\n\n          break;\n\n        case 8:\n          // rrcurveto\n          while (stack.length > 0) {\n            c1x = x + stack.shift();\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + stack.shift();\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n\n          break;\n\n        case 10:\n          // callsubr\n          codeIndex = stack.pop() + subrsBias;\n          subrCode = subrs[codeIndex];\n\n          if (subrCode) {\n            parse(subrCode);\n          }\n\n          break;\n\n        case 11:\n          // return\n          return;\n\n        case 12:\n          // flex operators\n          v = code[i];\n          i += 1;\n\n          switch (v) {\n            case 35:\n              // flex\n              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n              c1x = x + stack.shift(); // dx1\n\n              c1y = y + stack.shift(); // dy1\n\n              c2x = c1x + stack.shift(); // dx2\n\n              c2y = c1y + stack.shift(); // dy2\n\n              jpx = c2x + stack.shift(); // dx3\n\n              jpy = c2y + stack.shift(); // dy3\n\n              c3x = jpx + stack.shift(); // dx4\n\n              c3y = jpy + stack.shift(); // dy4\n\n              c4x = c3x + stack.shift(); // dx5\n\n              c4y = c3y + stack.shift(); // dy5\n\n              x = c4x + stack.shift(); // dx6\n\n              y = c4y + stack.shift(); // dy6\n\n              stack.shift(); // flex depth\n\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n\n            case 34:\n              // hflex\n              // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n              c1x = x + stack.shift(); // dx1\n\n              c1y = y; // dy1\n\n              c2x = c1x + stack.shift(); // dx2\n\n              c2y = c1y + stack.shift(); // dy2\n\n              jpx = c2x + stack.shift(); // dx3\n\n              jpy = c2y; // dy3\n\n              c3x = jpx + stack.shift(); // dx4\n\n              c3y = c2y; // dy4\n\n              c4x = c3x + stack.shift(); // dx5\n\n              c4y = y; // dy5\n\n              x = c4x + stack.shift(); // dx6\n\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n\n            case 36:\n              // hflex1\n              // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n              c1x = x + stack.shift(); // dx1\n\n              c1y = y + stack.shift(); // dy1\n\n              c2x = c1x + stack.shift(); // dx2\n\n              c2y = c1y + stack.shift(); // dy2\n\n              jpx = c2x + stack.shift(); // dx3\n\n              jpy = c2y; // dy3\n\n              c3x = jpx + stack.shift(); // dx4\n\n              c3y = c2y; // dy4\n\n              c4x = c3x + stack.shift(); // dx5\n\n              c4y = c3y + stack.shift(); // dy5\n\n              x = c4x + stack.shift(); // dx6\n\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n\n            case 37:\n              // flex1\n              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n              c1x = x + stack.shift(); // dx1\n\n              c1y = y + stack.shift(); // dy1\n\n              c2x = c1x + stack.shift(); // dx2\n\n              c2y = c1y + stack.shift(); // dy2\n\n              jpx = c2x + stack.shift(); // dx3\n\n              jpy = c2y + stack.shift(); // dy3\n\n              c3x = jpx + stack.shift(); // dx4\n\n              c3y = jpy + stack.shift(); // dy4\n\n              c4x = c3x + stack.shift(); // dx5\n\n              c4y = c3y + stack.shift(); // dy5\n\n              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                x = c4x + stack.shift();\n              } else {\n                y = c4y + stack.shift();\n              }\n\n              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n              p.curveTo(c3x, c3y, c4x, c4y, x, y);\n              break;\n\n            default:\n              console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n              stack.length = 0;\n          }\n\n          break;\n\n        case 14:\n          // endchar\n          if (stack.length > 0 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n\n          if (open) {\n            p.closePath();\n            open = false;\n          }\n\n          break;\n\n        case 18:\n          // hstemhm\n          parseStems();\n          break;\n\n        case 19: // hintmask\n\n        case 20:\n          // cntrmask\n          parseStems();\n          i += nStems + 7 >> 3;\n          break;\n\n        case 21:\n          // rmoveto\n          if (stack.length > 2 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n\n          y += stack.pop();\n          x += stack.pop();\n          newContour(x, y);\n          break;\n\n        case 22:\n          // hmoveto\n          if (stack.length > 1 && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n            haveWidth = true;\n          }\n\n          x += stack.pop();\n          newContour(x, y);\n          break;\n\n        case 23:\n          // vstemhm\n          parseStems();\n          break;\n\n        case 24:\n          // rcurveline\n          while (stack.length > 2) {\n            c1x = x + stack.shift();\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + stack.shift();\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n\n          x += stack.shift();\n          y += stack.shift();\n          p.lineTo(x, y);\n          break;\n\n        case 25:\n          // rlinecurve\n          while (stack.length > 6) {\n            x += stack.shift();\n            y += stack.shift();\n            p.lineTo(x, y);\n          }\n\n          c1x = x + stack.shift();\n          c1y = y + stack.shift();\n          c2x = c1x + stack.shift();\n          c2y = c1y + stack.shift();\n          x = c2x + stack.shift();\n          y = c2y + stack.shift();\n          p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          break;\n\n        case 26:\n          // vvcurveto\n          if (stack.length % 2) {\n            x += stack.shift();\n          }\n\n          while (stack.length > 0) {\n            c1x = x;\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x;\n            y = c2y + stack.shift();\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n\n          break;\n\n        case 27:\n          // hhcurveto\n          if (stack.length % 2) {\n            y += stack.shift();\n          }\n\n          while (stack.length > 0) {\n            c1x = x + stack.shift();\n            c1y = y;\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y;\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n\n          break;\n\n        case 28:\n          // shortint\n          b1 = code[i];\n          b2 = code[i + 1];\n          stack.push((b1 << 24 | b2 << 16) >> 16);\n          i += 2;\n          break;\n\n        case 29:\n          // callgsubr\n          codeIndex = stack.pop() + font.gsubrsBias;\n          subrCode = font.gsubrs[codeIndex];\n\n          if (subrCode) {\n            parse(subrCode);\n          }\n\n          break;\n\n        case 30:\n          // vhcurveto\n          while (stack.length > 0) {\n            c1x = x;\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\n            if (stack.length === 0) {\n              break;\n            }\n\n            c1x = x + stack.shift();\n            c1y = y;\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            y = c2y + stack.shift();\n            x = c2x + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n\n          break;\n\n        case 31:\n          // hvcurveto\n          while (stack.length > 0) {\n            c1x = x + stack.shift();\n            c1y = y;\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            y = c2y + stack.shift();\n            x = c2x + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\n            if (stack.length === 0) {\n              break;\n            }\n\n            c1x = x;\n            c1y = y + stack.shift();\n            c2x = c1x + stack.shift();\n            c2y = c1y + stack.shift();\n            x = c2x + stack.shift();\n            y = c2y + (stack.length === 1 ? stack.shift() : 0);\n            p.curveTo(c1x, c1y, c2x, c2y, x, y);\n          }\n\n          break;\n\n        default:\n          if (v < 32) {\n            console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n          } else if (v < 247) {\n            stack.push(v - 139);\n          } else if (v < 251) {\n            b1 = code[i];\n            i += 1;\n            stack.push((v - 247) * 256 + b1 + 108);\n          } else if (v < 255) {\n            b1 = code[i];\n            i += 1;\n            stack.push(-(v - 251) * 256 - b1 - 108);\n          } else {\n            b1 = code[i];\n            b2 = code[i + 1];\n            b3 = code[i + 2];\n            b4 = code[i + 3];\n            i += 4;\n            stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);\n          }\n\n      }\n    }\n  }\n\n  parse(code);\n  glyph.advanceWidth = width;\n  return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n  var fdSelect = [];\n  var fdIndex;\n  var parser = new parse.Parser(data, start);\n  var format = parser.parseCard8();\n\n  if (format === 0) {\n    // Simple list of nGlyphs elements\n    for (var iGid = 0; iGid < nGlyphs; iGid++) {\n      fdIndex = parser.parseCard8();\n\n      if (fdIndex >= fdArrayCount) {\n        throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n      }\n\n      fdSelect.push(fdIndex);\n    }\n  } else if (format === 3) {\n    // Ranges\n    var nRanges = parser.parseCard16();\n    var first = parser.parseCard16();\n\n    if (first !== 0) {\n      throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n    }\n\n    var next;\n\n    for (var iRange = 0; iRange < nRanges; iRange++) {\n      fdIndex = parser.parseCard8();\n      next = parser.parseCard16();\n\n      if (fdIndex >= fdArrayCount) {\n        throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n      }\n\n      if (next > nGlyphs) {\n        throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n      }\n\n      for (; first < next; first++) {\n        fdSelect.push(fdIndex);\n      }\n\n      first = next;\n    }\n\n    if (next !== nGlyphs) {\n      throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n    }\n  } else {\n    throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n  }\n\n  return fdSelect;\n} // Parse the `CFF` table, which contains the glyph outlines in PostScript format.\n\n\nfunction parseCFFTable(data, start, font, opt) {\n  font.tables.cff = {};\n  var header = parseCFFHeader(data, start);\n  var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n  var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n  var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n  var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n  font.gsubrs = globalSubrIndex.objects;\n  font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n  var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n\n  if (topDictArray.length !== 1) {\n    throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n  }\n\n  var topDict = topDictArray[0];\n  font.tables.cff.topDict = topDict;\n\n  if (topDict._privateDict) {\n    font.defaultWidthX = topDict._privateDict.defaultWidthX;\n    font.nominalWidthX = topDict._privateDict.nominalWidthX;\n  }\n\n  if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n    font.isCIDFont = true;\n  }\n\n  if (font.isCIDFont) {\n    var fdArrayOffset = topDict.fdArray;\n    var fdSelectOffset = topDict.fdSelect;\n\n    if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n      throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n    }\n\n    fdArrayOffset += start;\n    var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n    var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n    topDict._fdArray = fdArray;\n    fdSelectOffset += start;\n    topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n  }\n\n  var privateDictOffset = start + topDict.private[1];\n  var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n  font.defaultWidthX = privateDict.defaultWidthX;\n  font.nominalWidthX = privateDict.nominalWidthX;\n\n  if (privateDict.subrs !== 0) {\n    var subrOffset = privateDictOffset + privateDict.subrs;\n    var subrIndex = parseCFFIndex(data, subrOffset);\n    font.subrs = subrIndex.objects;\n    font.subrsBias = calcCFFSubroutineBias(font.subrs);\n  } else {\n    font.subrs = [];\n    font.subrsBias = 0;\n  } // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n\n\n  var charStringsIndex;\n\n  if (opt.lowMemory) {\n    charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n    font.nGlyphs = charStringsIndex.offsets.length;\n  } else {\n    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n    font.nGlyphs = charStringsIndex.objects.length;\n  }\n\n  var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n\n  if (topDict.encoding === 0) {\n    // Standard encoding\n    font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n  } else if (topDict.encoding === 1) {\n    // Expert encoding\n    font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n  } else {\n    font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n  } // Prefer the CMAP encoding to the CFF encoding.\n\n\n  font.encoding = font.encoding || font.cffEncoding;\n  font.glyphs = new glyphset.GlyphSet(font);\n\n  if (opt.lowMemory) {\n    font._push = function (i) {\n      var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n      font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n    };\n  } else {\n    for (var i = 0; i < font.nGlyphs; i += 1) {\n      var charString = charStringsIndex.objects[i];\n      font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n    }\n  }\n} // Convert a string to a String ID (SID).\n// The list of strings is modified in place.\n\n\nfunction encodeString(s, strings) {\n  var sid; // Is the string in the CFF standard strings?\n\n  var i = cffStandardStrings.indexOf(s);\n\n  if (i >= 0) {\n    sid = i;\n  } // Is the string already in the string index?\n\n\n  i = strings.indexOf(s);\n\n  if (i >= 0) {\n    sid = i + cffStandardStrings.length;\n  } else {\n    sid = cffStandardStrings.length + strings.length;\n    strings.push(s);\n  }\n\n  return sid;\n}\n\nfunction makeHeader() {\n  return new table.Record('Header', [{\n    name: 'major',\n    type: 'Card8',\n    value: 1\n  }, {\n    name: 'minor',\n    type: 'Card8',\n    value: 0\n  }, {\n    name: 'hdrSize',\n    type: 'Card8',\n    value: 4\n  }, {\n    name: 'major',\n    type: 'Card8',\n    value: 1\n  }]);\n}\n\nfunction makeNameIndex(fontNames) {\n  var t = new table.Record('Name INDEX', [{\n    name: 'names',\n    type: 'INDEX',\n    value: []\n  }]);\n  t.names = [];\n\n  for (var i = 0; i < fontNames.length; i += 1) {\n    t.names.push({\n      name: 'name_' + i,\n      type: 'NAME',\n      value: fontNames[i]\n    });\n  }\n\n  return t;\n} // Given a dictionary's metadata, create a DICT structure.\n\n\nfunction makeDict(meta, attrs, strings) {\n  var m = {};\n\n  for (var i = 0; i < meta.length; i += 1) {\n    var entry = meta[i];\n    var value = attrs[entry.name];\n\n    if (value !== undefined && !equals(value, entry.value)) {\n      if (entry.type === 'SID') {\n        value = encodeString(value, strings);\n      }\n\n      m[entry.op] = {\n        name: entry.name,\n        type: entry.type,\n        value: value\n      };\n    }\n  }\n\n  return m;\n} // The Top DICT houses the global font attributes.\n\n\nfunction makeTopDict(attrs, strings) {\n  var t = new table.Record('Top DICT', [{\n    name: 'dict',\n    type: 'DICT',\n    value: {}\n  }]);\n  t.dict = makeDict(TOP_DICT_META, attrs, strings);\n  return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n  var t = new table.Record('Top DICT INDEX', [{\n    name: 'topDicts',\n    type: 'INDEX',\n    value: []\n  }]);\n  t.topDicts = [{\n    name: 'topDict_0',\n    type: 'TABLE',\n    value: topDict\n  }];\n  return t;\n}\n\nfunction makeStringIndex(strings) {\n  var t = new table.Record('String INDEX', [{\n    name: 'strings',\n    type: 'INDEX',\n    value: []\n  }]);\n  t.strings = [];\n\n  for (var i = 0; i < strings.length; i += 1) {\n    t.strings.push({\n      name: 'string_' + i,\n      type: 'STRING',\n      value: strings[i]\n    });\n  }\n\n  return t;\n}\n\nfunction makeGlobalSubrIndex() {\n  // Currently we don't use subroutines.\n  return new table.Record('Global Subr INDEX', [{\n    name: 'subrs',\n    type: 'INDEX',\n    value: []\n  }]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n  var t = new table.Record('Charsets', [{\n    name: 'format',\n    type: 'Card8',\n    value: 0\n  }]);\n\n  for (var i = 0; i < glyphNames.length; i += 1) {\n    var glyphName = glyphNames[i];\n    var glyphSID = encodeString(glyphName, strings);\n    t.fields.push({\n      name: 'glyph_' + i,\n      type: 'SID',\n      value: glyphSID\n    });\n  }\n\n  return t;\n}\n\nfunction glyphToOps(glyph) {\n  var ops = [];\n  var path = glyph.path;\n  ops.push({\n    name: 'width',\n    type: 'NUMBER',\n    value: glyph.advanceWidth\n  });\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0; i < path.commands.length; i += 1) {\n    var dx = void 0;\n    var dy = void 0;\n    var cmd = path.commands[i];\n\n    if (cmd.type === 'Q') {\n      // CFF only supports bézier curves, so convert the quad to a bézier.\n      var _13 = 1 / 3;\n\n      var _23 = 2 / 3; // We're going to create a new command so we don't change the original path.\n\n\n      cmd = {\n        type: 'C',\n        x: cmd.x,\n        y: cmd.y,\n        x1: _13 * x + _23 * cmd.x1,\n        y1: _13 * y + _23 * cmd.y1,\n        x2: _13 * cmd.x + _23 * cmd.x1,\n        y2: _13 * cmd.y + _23 * cmd.y1\n      };\n    }\n\n    if (cmd.type === 'M') {\n      dx = Math.round(cmd.x - x);\n      dy = Math.round(cmd.y - y);\n      ops.push({\n        name: 'dx',\n        type: 'NUMBER',\n        value: dx\n      });\n      ops.push({\n        name: 'dy',\n        type: 'NUMBER',\n        value: dy\n      });\n      ops.push({\n        name: 'rmoveto',\n        type: 'OP',\n        value: 21\n      });\n      x = Math.round(cmd.x);\n      y = Math.round(cmd.y);\n    } else if (cmd.type === 'L') {\n      dx = Math.round(cmd.x - x);\n      dy = Math.round(cmd.y - y);\n      ops.push({\n        name: 'dx',\n        type: 'NUMBER',\n        value: dx\n      });\n      ops.push({\n        name: 'dy',\n        type: 'NUMBER',\n        value: dy\n      });\n      ops.push({\n        name: 'rlineto',\n        type: 'OP',\n        value: 5\n      });\n      x = Math.round(cmd.x);\n      y = Math.round(cmd.y);\n    } else if (cmd.type === 'C') {\n      var dx1 = Math.round(cmd.x1 - x);\n      var dy1 = Math.round(cmd.y1 - y);\n      var dx2 = Math.round(cmd.x2 - cmd.x1);\n      var dy2 = Math.round(cmd.y2 - cmd.y1);\n      dx = Math.round(cmd.x - cmd.x2);\n      dy = Math.round(cmd.y - cmd.y2);\n      ops.push({\n        name: 'dx1',\n        type: 'NUMBER',\n        value: dx1\n      });\n      ops.push({\n        name: 'dy1',\n        type: 'NUMBER',\n        value: dy1\n      });\n      ops.push({\n        name: 'dx2',\n        type: 'NUMBER',\n        value: dx2\n      });\n      ops.push({\n        name: 'dy2',\n        type: 'NUMBER',\n        value: dy2\n      });\n      ops.push({\n        name: 'dx',\n        type: 'NUMBER',\n        value: dx\n      });\n      ops.push({\n        name: 'dy',\n        type: 'NUMBER',\n        value: dy\n      });\n      ops.push({\n        name: 'rrcurveto',\n        type: 'OP',\n        value: 8\n      });\n      x = Math.round(cmd.x);\n      y = Math.round(cmd.y);\n    } // Contours are closed automatically.\n\n  }\n\n  ops.push({\n    name: 'endchar',\n    type: 'OP',\n    value: 14\n  });\n  return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n  var t = new table.Record('CharStrings INDEX', [{\n    name: 'charStrings',\n    type: 'INDEX',\n    value: []\n  }]);\n\n  for (var i = 0; i < glyphs.length; i += 1) {\n    var glyph = glyphs.get(i);\n    var ops = glyphToOps(glyph);\n    t.charStrings.push({\n      name: glyph.name,\n      type: 'CHARSTRING',\n      value: ops\n    });\n  }\n\n  return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n  var t = new table.Record('Private DICT', [{\n    name: 'dict',\n    type: 'DICT',\n    value: {}\n  }]);\n  t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n  return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n  var t = new table.Table('CFF ', [{\n    name: 'header',\n    type: 'RECORD'\n  }, {\n    name: 'nameIndex',\n    type: 'RECORD'\n  }, {\n    name: 'topDictIndex',\n    type: 'RECORD'\n  }, {\n    name: 'stringIndex',\n    type: 'RECORD'\n  }, {\n    name: 'globalSubrIndex',\n    type: 'RECORD'\n  }, {\n    name: 'charsets',\n    type: 'RECORD'\n  }, {\n    name: 'charStringsIndex',\n    type: 'RECORD'\n  }, {\n    name: 'privateDict',\n    type: 'RECORD'\n  }]);\n  var fontScale = 1 / options.unitsPerEm; // We use non-zero values for the offsets so that the DICT encodes them.\n  // This is important because the size of the Top DICT plays a role in offset calculation,\n  // and the size shouldn't change after we've written correct offsets.\n\n  var attrs = {\n    version: options.version,\n    fullName: options.fullName,\n    familyName: options.familyName,\n    weight: options.weightName,\n    fontBBox: options.fontBBox || [0, 0, 0, 0],\n    fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n    charset: 999,\n    encoding: 0,\n    charStrings: 999,\n    private: [0, 999]\n  };\n  var privateAttrs = {};\n  var glyphNames = [];\n  var glyph; // Skip first glyph (.notdef)\n\n  for (var i = 1; i < glyphs.length; i += 1) {\n    glyph = glyphs.get(i);\n    glyphNames.push(glyph.name);\n  }\n\n  var strings = [];\n  t.header = makeHeader();\n  t.nameIndex = makeNameIndex([options.postScriptName]);\n  var topDict = makeTopDict(attrs, strings);\n  t.topDictIndex = makeTopDictIndex(topDict);\n  t.globalSubrIndex = makeGlobalSubrIndex();\n  t.charsets = makeCharsets(glyphNames, strings);\n  t.charStringsIndex = makeCharStringsIndex(glyphs);\n  t.privateDict = makePrivateDict(privateAttrs, strings); // Needs to come at the end, to encode all custom strings used in the font.\n\n  t.stringIndex = makeStringIndex(strings);\n  var startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();\n  attrs.charset = startOffset; // We use the CFF standard encoding; proper encoding will be handled in cmap.\n\n  attrs.encoding = 0;\n  attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n  attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf(); // Recreate the Top DICT INDEX with the correct offsets.\n\n  topDict = makeTopDict(attrs, strings);\n  t.topDictIndex = makeTopDictIndex(topDict);\n  return t;\n}\n\nexport default {\n  parse: parseCFFTable,\n  make: makeCFFTable\n};","map":null,"metadata":{},"sourceType":"module"}