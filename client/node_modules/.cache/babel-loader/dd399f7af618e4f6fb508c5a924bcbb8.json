{"ast":null,"code":"// Data types used in the OpenType font file.\n// All OpenType fonts use Motorola-style byte ordering (Big Endian)\nimport check from './check';\nvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\n\nvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\n\nvar decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\n\nvar encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\n\nvar sizeOf = {}; // Return a function that always returns the same value.\n\nfunction constant(v) {\n  return function () {\n    return v;\n  };\n} // OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\n\n\nencode.BYTE = function (v) {\n  check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n  return [v];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.BYTE = constant(1);\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\n\nencode.CHAR = function (v) {\n  return [v.charCodeAt(0)];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.CHAR = constant(1);\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\n\nencode.CHARARRAY = function (v) {\n  var b = [];\n\n  for (var i = 0; i < v.length; i += 1) {\n    b[i] = v.charCodeAt(i);\n  }\n\n  return b;\n};\n/**\n * @param {Array}\n * @returns {number}\n */\n\n\nsizeOf.CHARARRAY = function (v) {\n  return v.length;\n};\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\n\n\nencode.USHORT = function (v) {\n  return [v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.USHORT = constant(2);\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\n\nencode.SHORT = function (v) {\n  // Two's complement\n  if (v >= LIMIT16) {\n    v = -(2 * LIMIT16 - v);\n  }\n\n  return [v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.SHORT = constant(2);\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\n\nencode.UINT24 = function (v) {\n  return [v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.UINT24 = constant(3);\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\n\nencode.ULONG = function (v) {\n  return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.ULONG = constant(4);\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\n\nencode.LONG = function (v) {\n  // Two's complement\n  if (v >= LIMIT32) {\n    v = -(2 * LIMIT32 - v);\n  }\n\n  return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.LONG = constant(4);\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\n\nencode.LONGDATETIME = function (v) {\n  return [0, 0, 0, 0, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.LONGDATETIME = constant(8);\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\n\nencode.TAG = function (v) {\n  check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n  return [v.charCodeAt(0), v.charCodeAt(1), v.charCodeAt(2), v.charCodeAt(3)];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.TAG = constant(4); // CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT; // Convert a numeric operand or charstring number to a variable-size list of bytes.\n\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\n\nencode.NUMBER = function (v) {\n  if (v >= -107 && v <= 107) {\n    return [v + 139];\n  } else if (v >= 108 && v <= 1131) {\n    v = v - 108;\n    return [(v >> 8) + 247, v & 0xFF];\n  } else if (v >= -1131 && v <= -108) {\n    v = -v - 108;\n    return [(v >> 8) + 251, v & 0xFF];\n  } else if (v >= -32768 && v <= 32767) {\n    return encode.NUMBER16(v);\n  } else {\n    return encode.NUMBER32(v);\n  }\n};\n/**\n * @param {number}\n * @returns {number}\n */\n\n\nsizeOf.NUMBER = function (v) {\n  return encode.NUMBER(v).length;\n};\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\n\n\nencode.NUMBER16 = function (v) {\n  return [28, v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.NUMBER16 = constant(3);\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\n\nencode.NUMBER32 = function (v) {\n  return [29, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];\n};\n/**\n * @constant\n * @type {number}\n */\n\n\nsizeOf.NUMBER32 = constant(5);\n/**\n * @param {number}\n * @returns {Array}\n */\n\nencode.REAL = function (v) {\n  var value = v.toString(); // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n  // This code converts it back to a number without the epsilon.\n\n  var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n\n  if (m) {\n    var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n    value = (Math.round(v * epsilon) / epsilon).toString();\n  }\n\n  var nibbles = '';\n\n  for (var i = 0, ii = value.length; i < ii; i += 1) {\n    var c = value[i];\n\n    if (c === 'e') {\n      nibbles += value[++i] === '-' ? 'c' : 'b';\n    } else if (c === '.') {\n      nibbles += 'a';\n    } else if (c === '-') {\n      nibbles += 'e';\n    } else {\n      nibbles += c;\n    }\n  }\n\n  nibbles += nibbles.length & 1 ? 'f' : 'ff';\n  var out = [30];\n\n  for (var _i = 0, _ii = nibbles.length; _i < _ii; _i += 2) {\n    out.push(parseInt(nibbles.substr(_i, 2), 16));\n  }\n\n  return out;\n};\n/**\n * @param {number}\n * @returns {number}\n */\n\n\nsizeOf.REAL = function (v) {\n  return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\n\ndecode.UTF8 = function (data, offset, numBytes) {\n  var codePoints = [];\n  var numChars = numBytes;\n\n  for (var j = 0; j < numChars; j++, offset += 1) {\n    codePoints[j] = data.getUint8(offset);\n  }\n\n  return String.fromCharCode.apply(null, codePoints);\n};\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\n\n\ndecode.UTF16 = function (data, offset, numBytes) {\n  var codePoints = [];\n  var numChars = numBytes / 2;\n\n  for (var j = 0; j < numChars; j++, offset += 2) {\n    codePoints[j] = data.getUint16(offset);\n  }\n\n  return String.fromCharCode.apply(null, codePoints);\n};\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\n\n\nencode.UTF16 = function (v) {\n  var b = [];\n\n  for (var i = 0; i < v.length; i += 1) {\n    var codepoint = v.charCodeAt(i);\n    b[b.length] = codepoint >> 8 & 0xFF;\n    b[b.length] = codepoint & 0xFF;\n  }\n\n  return b;\n};\n/**\n * @param {string}\n * @returns {number}\n */\n\n\nsizeOf.UTF16 = function (v) {\n  return v.length * 2;\n}; // Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n\n/**\n * @private\n */\n\n\nvar eightBitMacEncodings = {\n  'x-mac-croatian': // Python: 'mac_croatian'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' + '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n  'x-mac-cyrillic': // Python: 'mac_cyrillic'\n  'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' + 'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n  'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' + 'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n  'x-mac-greek': // Python: 'mac_greek'\n  'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' + \"\\u03AC\\u039D\\xAC\\u039F\\u03A1\\u2248\\u03A4\\xAB\\xBB\\u2026\\xA0\\u03A5\\u03A7\\u0386\\u0388\\u0153\\u2013\\u2015\\u201C\\u201D\\u2018\\u2019\\xF7\\u0389\\u038A\\u038C\\u038E\\u03AD\\u03AE\\u03AF\\u03CC\\u038F\\u03CD\\u03B1\\u03B2\\u03C8\\u03B4\\u03B5\\u03C6\\u03B3\\u03B7\\u03B9\\u03BE\\u03BA\\u03BB\\u03BC\\u03BD\\u03BF\\u03C0\\u03CE\\u03C1\\u03C3\\u03C4\\u03B8\\u03C9\\u03C2\\u03C7\\u03C5\\u03B6\\u03CA\\u03CB\\u0390\\u03B0\\xAD\",\n  'x-mac-icelandic': // Python: 'mac_iceland'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n  'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n  'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' + 'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n  'x-mac-ce': // Python: 'mac_latin2'\n  'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' + 'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n  macintosh: // Python: 'mac_roman'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n  'x-mac-romanian': // Python: 'mac_romanian'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n  'x-mac-turkish': // Python: 'mac_turkish'\n  'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\n\ndecode.MACSTRING = function (dataView, offset, dataLength, encoding) {\n  var table = eightBitMacEncodings[encoding];\n\n  if (table === undefined) {\n    return undefined;\n  }\n\n  var result = '';\n\n  for (var i = 0; i < dataLength; i++) {\n    var c = dataView.getUint8(offset + i); // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n    // mapped to U+0000..U+007F; we only need to look up the others.\n\n    if (c <= 0x7F) {\n      result += String.fromCharCode(c);\n    } else {\n      result += table[c & 0x7F];\n    }\n  }\n\n  return result;\n}; // Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\n\n\nvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nvar macEncodingCacheKeys;\n\nvar getMacEncodingTable = function getMacEncodingTable(encoding) {\n  // Since we use encoding as a cache key for WeakMap, it has to be\n  // a String object and not a literal. And at least on NodeJS 2.10.1,\n  // WeakMap requires that the same String instance is passed for cache hits.\n  if (!macEncodingCacheKeys) {\n    macEncodingCacheKeys = {};\n\n    for (var e in eightBitMacEncodings) {\n      /*jshint -W053 */\n      // Suppress \"Do not use String as a constructor.\"\n      macEncodingCacheKeys[e] = new String(e);\n    }\n  }\n\n  var cacheKey = macEncodingCacheKeys[encoding];\n\n  if (cacheKey === undefined) {\n    return undefined;\n  } // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n  // since garbage collection may run at any time, it could also kick in\n  // between the calls to cache.has() and cache.get(). In that case,\n  // we would return 'undefined' even though we do support the encoding.\n\n\n  if (macEncodingTableCache) {\n    var cachedTable = macEncodingTableCache.get(cacheKey);\n\n    if (cachedTable !== undefined) {\n      return cachedTable;\n    }\n  }\n\n  var decodingTable = eightBitMacEncodings[encoding];\n\n  if (decodingTable === undefined) {\n    return undefined;\n  }\n\n  var encodingTable = {};\n\n  for (var i = 0; i < decodingTable.length; i++) {\n    encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n  }\n\n  if (macEncodingTableCache) {\n    macEncodingTableCache.set(cacheKey, encodingTable);\n  }\n\n  return encodingTable;\n};\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\n\n\nencode.MACSTRING = function (str, encoding) {\n  var table = getMacEncodingTable(encoding);\n\n  if (table === undefined) {\n    return undefined;\n  }\n\n  var result = [];\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i); // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n    // mapped to U+0000..U+007F; we only need to look up the others.\n\n    if (c >= 0x80) {\n      c = table[c];\n\n      if (c === undefined) {\n        // str contains a Unicode character that cannot be encoded\n        // in the requested encoding.\n        return undefined;\n      }\n    }\n\n    result[i] = c; // result.push(c);\n  }\n\n  return result;\n};\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\n\n\nsizeOf.MACSTRING = function (str, encoding) {\n  var b = encode.MACSTRING(str, encoding);\n\n  if (b !== undefined) {\n    return b.length;\n  } else {\n    return 0;\n  }\n}; // Helper for encode.VARDELTAS\n\n\nfunction isByteEncodable(value) {\n  return value >= -128 && value <= 127;\n} // Helper for encode.VARDELTAS\n\n\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n  var runLength = 0;\n  var numDeltas = deltas.length;\n\n  while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n    ++pos;\n    ++runLength;\n  }\n\n  result.push(0x80 | runLength - 1);\n  return pos;\n} // Helper for encode.VARDELTAS\n\n\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n  var runLength = 0;\n  var numDeltas = deltas.length;\n  var pos = offset;\n\n  while (pos < numDeltas && runLength < 64) {\n    var value = deltas[pos];\n\n    if (!isByteEncodable(value)) {\n      break;\n    } // Within a byte-encoded run of deltas, a single zero is best\n    // stored literally as 0x00 value. However, if we have two or\n    // more zeroes in a sequence, it is better to start a new run.\n    // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n    // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n    // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n    // when starting a new run.\n\n\n    if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n      break;\n    }\n\n    ++pos;\n    ++runLength;\n  }\n\n  result.push(runLength - 1);\n\n  for (var i = offset; i < pos; ++i) {\n    result.push(deltas[i] + 256 & 0xff);\n  }\n\n  return pos;\n} // Helper for encode.VARDELTAS\n\n\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n  var runLength = 0;\n  var numDeltas = deltas.length;\n  var pos = offset;\n\n  while (pos < numDeltas && runLength < 64) {\n    var value = deltas[pos]; // Within a word-encoded run of deltas, it is easiest to start\n    // a new run (with a different encoding) whenever we encounter\n    // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n    // needs 7 bytes when storing the zero inside the current run\n    // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n    // new run (40 66 66 80 40 77 77).\n\n    if (value === 0) {\n      break;\n    } // Within a word-encoded run of deltas, a single value in the\n    // range (-128..127) should be encoded within the current run\n    // because it is more compact. For example, the sequence\n    // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n    // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n    // a new run (40 66 66 00 02 40 77 77).\n\n\n    if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n      break;\n    }\n\n    ++pos;\n    ++runLength;\n  }\n\n  result.push(0x40 | runLength - 1);\n\n  for (var i = offset; i < pos; ++i) {\n    var val = deltas[i];\n    result.push(val + 0x10000 >> 8 & 0xff, val + 0x100 & 0xff);\n  }\n\n  return pos;\n}\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\n\n\nencode.VARDELTAS = function (deltas) {\n  var pos = 0;\n  var result = [];\n\n  while (pos < deltas.length) {\n    var value = deltas[pos];\n\n    if (value === 0) {\n      pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n    } else if (value >= -128 && value <= 127) {\n      pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n    } else {\n      pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n    }\n  }\n\n  return result;\n}; // Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n\n/**\n * @param {Array} l\n * @returns {Array}\n */\n\n\nencode.INDEX = function (l) {\n  //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n  //    i, v;\n  // Because we have to know which data type to use to encode the offsets,\n  // we have to go through the values twice: once to encode the data and\n  // calculate the offsets, then again to encode the offsets using the fitting data type.\n  var offset = 1; // First offset is always 1.\n\n  var offsets = [offset];\n  var data = [];\n\n  for (var i = 0; i < l.length; i += 1) {\n    var v = encode.OBJECT(l[i]);\n    Array.prototype.push.apply(data, v);\n    offset += v.length;\n    offsets.push(offset);\n  }\n\n  if (data.length === 0) {\n    return [0, 0];\n  }\n\n  var encodedOffsets = [];\n  var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;\n  var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n\n  for (var _i2 = 0; _i2 < offsets.length; _i2 += 1) {\n    var encodedOffset = offsetEncoder(offsets[_i2]);\n    Array.prototype.push.apply(encodedOffsets, encodedOffset);\n  }\n\n  return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data);\n};\n/**\n * @param {Array}\n * @returns {number}\n */\n\n\nsizeOf.INDEX = function (v) {\n  return encode.INDEX(v).length;\n};\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\n\n\nencode.DICT = function (m) {\n  var d = [];\n  var keys = Object.keys(m);\n  var length = keys.length;\n\n  for (var i = 0; i < length; i += 1) {\n    // Object.keys() return string keys, but our keys are always numeric.\n    var k = parseInt(keys[i], 0);\n    var v = m[k]; // Value comes before the key.\n\n    d = d.concat(encode.OPERAND(v.value, v.type));\n    d = d.concat(encode.OPERATOR(k));\n  }\n\n  return d;\n};\n/**\n * @param {Object}\n * @returns {number}\n */\n\n\nsizeOf.DICT = function (m) {\n  return encode.DICT(m).length;\n};\n/**\n * @param {number}\n * @returns {Array}\n */\n\n\nencode.OPERATOR = function (v) {\n  if (v < 1200) {\n    return [v];\n  } else {\n    return [12, v - 1200];\n  }\n};\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\n\n\nencode.OPERAND = function (v, type) {\n  var d = [];\n\n  if (Array.isArray(type)) {\n    for (var i = 0; i < type.length; i += 1) {\n      check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n      d = d.concat(encode.OPERAND(v[i], type[i]));\n    }\n  } else {\n    if (type === 'SID') {\n      d = d.concat(encode.NUMBER(v));\n    } else if (type === 'offset') {\n      // We make it easy for ourselves and always encode offsets as\n      // 4 bytes. This makes offset calculation for the top dict easier.\n      d = d.concat(encode.NUMBER32(v));\n    } else if (type === 'number') {\n      d = d.concat(encode.NUMBER(v));\n    } else if (type === 'real') {\n      d = d.concat(encode.REAL(v));\n    } else {\n      throw new Error('Unknown operand type ' + type); // FIXME Add support for booleans\n    }\n  }\n\n  return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE; // memoize charstring encoding using WeakMap if available\n\nvar wmm = typeof WeakMap === 'function' && new WeakMap();\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\n\nencode.CHARSTRING = function (ops) {\n  // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n  if (wmm) {\n    var cachedValue = wmm.get(ops);\n\n    if (cachedValue !== undefined) {\n      return cachedValue;\n    }\n  }\n\n  var d = [];\n  var length = ops.length;\n\n  for (var i = 0; i < length; i += 1) {\n    var op = ops[i];\n    d = d.concat(encode[op.type](op.value));\n  }\n\n  if (wmm) {\n    wmm.set(ops, d);\n  }\n\n  return d;\n};\n/**\n * @param {Array}\n * @returns {number}\n */\n\n\nsizeOf.CHARSTRING = function (ops) {\n  return encode.CHARSTRING(ops).length;\n}; // Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\n\n\nencode.OBJECT = function (v) {\n  var encodingFunction = encode[v.type];\n  check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n  return encodingFunction(v.value);\n};\n/**\n * @param {Object}\n * @returns {number}\n */\n\n\nsizeOf.OBJECT = function (v) {\n  var sizeOfFunction = sizeOf[v.type];\n  check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n  return sizeOfFunction(v.value);\n};\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\n\n\nencode.TABLE = function (table) {\n  var d = [];\n  var length = table.fields.length;\n  var subtables = [];\n  var subtableOffsets = [];\n\n  for (var i = 0; i < length; i += 1) {\n    var field = table.fields[i];\n    var encodingFunction = encode[field.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n    var value = table[field.name];\n\n    if (value === undefined) {\n      value = field.value;\n    }\n\n    var bytes = encodingFunction(value);\n\n    if (field.type === 'TABLE') {\n      subtableOffsets.push(d.length);\n      d = d.concat([0, 0]);\n      subtables.push(bytes);\n    } else {\n      d = d.concat(bytes);\n    }\n  }\n\n  for (var _i3 = 0; _i3 < subtables.length; _i3 += 1) {\n    var o = subtableOffsets[_i3];\n    var offset = d.length;\n    check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n    d[o] = offset >> 8;\n    d[o + 1] = offset & 0xff;\n    d = d.concat(subtables[_i3]);\n  }\n\n  return d;\n};\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\n\n\nsizeOf.TABLE = function (table) {\n  var numBytes = 0;\n  var length = table.fields.length;\n\n  for (var i = 0; i < length; i += 1) {\n    var field = table.fields[i];\n    var sizeOfFunction = sizeOf[field.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n    var value = table[field.name];\n\n    if (value === undefined) {\n      value = field.value;\n    }\n\n    numBytes += sizeOfFunction(value); // Subtables take 2 more bytes for offsets.\n\n    if (field.type === 'TABLE') {\n      numBytes += 2;\n    }\n  }\n\n  return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE; // Merge in a list of bytes.\n\nencode.LITERAL = function (v) {\n  return v;\n};\n\nsizeOf.LITERAL = function (v) {\n  return v.length;\n};\n\nexport { decode, encode, sizeOf };","map":null,"metadata":{},"sourceType":"module"}