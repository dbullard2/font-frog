{"ast":null,"code":"/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n  this.char = char;\n  this.state = {};\n  this.activeState = null;\n}\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\n\n\nfunction ContextRange(startIndex, endOffset, contextName) {\n  this.contextName = contextName;\n  this.startIndex = startIndex;\n  this.endOffset = endOffset;\n}\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\n\n\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n  this.contextName = contextName;\n  this.openRange = null;\n  this.ranges = [];\n  this.checkStart = checkStart;\n  this.checkEnd = checkEnd;\n}\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\n\n\nfunction ContextParams(context, currentIndex) {\n  this.context = context;\n  this.index = currentIndex;\n  this.length = context.length;\n  this.current = context[currentIndex];\n  this.backtrack = context.slice(0, currentIndex);\n  this.lookahead = context.slice(currentIndex + 1);\n}\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\n\n\nfunction Event(eventId) {\n  this.eventId = eventId;\n  this.subscribers = [];\n}\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\n\n\nfunction initializeCoreEvents(events) {\n  var _this = this;\n\n  var coreEvents = ['start', 'end', 'next', 'newToken', 'contextStart', 'contextEnd', 'insertToken', 'removeToken', 'removeRange', 'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'];\n  coreEvents.forEach(function (eventId) {\n    Object.defineProperty(_this.events, eventId, {\n      value: new Event(eventId)\n    });\n  });\n\n  if (!!events) {\n    coreEvents.forEach(function (eventId) {\n      var event = events[eventId];\n\n      if (typeof event === 'function') {\n        _this.events[eventId].subscribe(event);\n      }\n    });\n  }\n\n  var requiresContextUpdate = ['insertToken', 'removeToken', 'removeRange', 'replaceToken', 'replaceRange', 'composeRUD'];\n  requiresContextUpdate.forEach(function (eventId) {\n    _this.events[eventId].subscribe(_this.updateContextsRanges);\n  });\n}\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\n\n\nfunction Tokenizer(events) {\n  this.tokens = [];\n  this.registeredContexts = {};\n  this.contextCheckers = [];\n  this.events = {};\n  this.registeredModifiers = [];\n  initializeCoreEvents.call(this, events);\n}\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\n\n\nToken.prototype.setState = function (key, value) {\n  this.state[key] = value;\n  this.activeState = {\n    key: key,\n    value: this.state[key]\n  };\n  return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n  return this.state[stateId] || null;\n};\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\n\n\nTokenizer.prototype.inboundIndex = function (index) {\n  return index >= 0 && index < this.tokens.length;\n};\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\n\n\nTokenizer.prototype.composeRUD = function (RUDs) {\n  var _this2 = this;\n\n  var silent = true;\n  var state = RUDs.map(function (RUD) {\n    return _this2[RUD[0]].apply(_this2, RUD.slice(1).concat(silent));\n  });\n\n  var hasFAILObject = function hasFAILObject(obj) {\n    return typeof obj === 'object' && obj.hasOwnProperty('FAIL');\n  };\n\n  if (state.every(hasFAILObject)) {\n    return {\n      FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n      report: state.filter(hasFAILObject)\n    };\n  }\n\n  this.dispatch('composeRUD', [state.filter(function (op) {\n    return !hasFAILObject(op);\n  })]);\n};\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\n\n\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n  offset = offset !== null ? offset : this.tokens.length;\n  var isTokenType = tokens.every(function (token) {\n    return token instanceof Token;\n  });\n\n  if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n    var replaced = this.tokens.splice.apply(this.tokens, [startIndex, offset].concat(tokens));\n    if (!silent) this.dispatch('replaceToken', [startIndex, offset, tokens]);\n    return [replaced, tokens];\n  } else {\n    return {\n      FAIL: 'replaceRange: invalid tokens or startIndex.'\n    };\n  }\n};\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\n\n\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n  if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n    var replaced = this.tokens.splice(index, 1, token);\n    if (!silent) this.dispatch('replaceToken', [index, token]);\n    return [replaced[0], token];\n  } else {\n    return {\n      FAIL: 'replaceToken: invalid token or index.'\n    };\n  }\n};\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\n\n\nTokenizer.prototype.removeRange = function (startIndex, offset, silent) {\n  offset = !isNaN(offset) ? offset : this.tokens.length;\n  var tokens = this.tokens.splice(startIndex, offset);\n  if (!silent) this.dispatch('removeRange', [tokens, startIndex, offset]);\n  return tokens;\n};\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\n\n\nTokenizer.prototype.removeToken = function (index, silent) {\n  if (!isNaN(index) && this.inboundIndex(index)) {\n    var token = this.tokens.splice(index, 1);\n    if (!silent) this.dispatch('removeToken', [token, index]);\n    return token;\n  } else {\n    return {\n      FAIL: 'removeToken: invalid token index.'\n    };\n  }\n};\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\n\n\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n  var tokenType = tokens.every(function (token) {\n    return token instanceof Token;\n  });\n\n  if (tokenType) {\n    this.tokens.splice.apply(this.tokens, [index, 0].concat(tokens));\n    if (!silent) this.dispatch('insertToken', [tokens, index]);\n    return tokens;\n  } else {\n    return {\n      FAIL: 'insertToken: invalid token(s).'\n    };\n  }\n};\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\n\n\nTokenizer.prototype.registerModifier = function (modifierId, condition, modifier) {\n  this.events.newToken.subscribe(function (token, contextParams) {\n    var conditionParams = [token, contextParams];\n    var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;\n    var modifierParams = [token, contextParams];\n\n    if (canApplyModifier) {\n      var newStateValue = modifier.apply(this, modifierParams);\n      token.setState(modifierId, newStateValue);\n    }\n  });\n  this.registeredModifiers.push(modifierId);\n};\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\n\n\nEvent.prototype.subscribe = function (eventHandler) {\n  if (typeof eventHandler === 'function') {\n    return this.subscribers.push(eventHandler) - 1;\n  } else {\n    return {\n      FAIL: \"invalid '\".concat(this.eventId, \"' event handler\")\n    };\n  }\n};\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\n\n\nEvent.prototype.unsubscribe = function (subsId) {\n  this.subscribers.splice(subsId, 1);\n};\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\n\n\nContextParams.prototype.setCurrentIndex = function (index) {\n  this.index = index;\n  this.current = this.context[index];\n  this.backtrack = this.context.slice(0, index);\n  this.lookahead = this.context.slice(index + 1);\n};\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\n\n\nContextParams.prototype.get = function (offset) {\n  switch (true) {\n    case offset === 0:\n      return this.current;\n\n    case offset < 0 && Math.abs(offset) <= this.backtrack.length:\n      return this.backtrack.slice(offset)[0];\n\n    case offset > 0 && offset <= this.lookahead.length:\n      return this.lookahead[offset - 1];\n\n    default:\n      return null;\n  }\n};\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\n\n\nTokenizer.prototype.rangeToText = function (range) {\n  if (range instanceof ContextRange) {\n    return this.getRangeTokens(range).map(function (token) {\n      return token.char;\n    }).join('');\n  }\n};\n/**\n * Converts all tokens into a string\n */\n\n\nTokenizer.prototype.getText = function () {\n  return this.tokens.map(function (token) {\n    return token.char;\n  }).join('');\n};\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\n\n\nTokenizer.prototype.getContext = function (contextName) {\n  var context = this.registeredContexts[contextName];\n  return !!context ? context : null;\n};\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\n\n\nTokenizer.prototype.on = function (eventName, eventHandler) {\n  var event = this.events[eventName];\n\n  if (!!event) {\n    return event.subscribe(eventHandler);\n  } else {\n    return null;\n  }\n};\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\n\n\nTokenizer.prototype.dispatch = function (eventName, args) {\n  var _this3 = this;\n\n  var event = this.events[eventName];\n\n  if (event instanceof Event) {\n    event.subscribers.forEach(function (subscriber) {\n      subscriber.apply(_this3, args || []);\n    });\n  }\n};\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\n\n\nTokenizer.prototype.registerContextChecker = function (contextName, contextStartCheck, contextEndCheck) {\n  if (!!this.getContext(contextName)) return {\n    FAIL: \"context name '\".concat(contextName, \"' is already registered.\")\n  };\n  if (typeof contextStartCheck !== 'function') return {\n    FAIL: \"missing context start check.\"\n  };\n  if (typeof contextEndCheck !== 'function') return {\n    FAIL: \"missing context end check.\"\n  };\n  var contextCheckers = new ContextChecker(contextName, contextStartCheck, contextEndCheck);\n  this.registeredContexts[contextName] = contextCheckers;\n  this.contextCheckers.push(contextCheckers);\n  return contextCheckers;\n};\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\n\n\nTokenizer.prototype.getRangeTokens = function (range) {\n  var endIndex = range.startIndex + range.endOffset;\n  return [].concat(this.tokens.slice(range.startIndex, endIndex));\n};\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\n\n\nTokenizer.prototype.getContextRanges = function (contextName) {\n  var context = this.getContext(contextName);\n\n  if (!!context) {\n    return context.ranges;\n  } else {\n    return {\n      FAIL: \"context checker '\".concat(contextName, \"' is not registered.\")\n    };\n  }\n};\n/**\n * Resets context ranges to run context update\n */\n\n\nTokenizer.prototype.resetContextsRanges = function () {\n  var registeredContexts = this.registeredContexts;\n\n  for (var contextName in registeredContexts) {\n    if (registeredContexts.hasOwnProperty(contextName)) {\n      var context = registeredContexts[contextName];\n      context.ranges = [];\n    }\n  }\n};\n/**\n * Updates context ranges\n */\n\n\nTokenizer.prototype.updateContextsRanges = function () {\n  this.resetContextsRanges();\n  var chars = this.tokens.map(function (token) {\n    return token.char;\n  });\n\n  for (var i = 0; i < chars.length; i++) {\n    var contextParams = new ContextParams(chars, i);\n    this.runContextCheck(contextParams);\n  }\n\n  this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\n\n\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n  var startIndex = this.getContext(contextName).openRange.startIndex;\n  var range = new ContextRange(startIndex, offset, contextName);\n  var ranges = this.getContext(contextName).ranges;\n  range.rangeId = \"\".concat(contextName, \".\").concat(ranges.length);\n  ranges.push(range);\n  this.getContext(contextName).openRange = null;\n  return range;\n};\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\n\n\nTokenizer.prototype.runContextCheck = function (contextParams) {\n  var _this4 = this;\n\n  var index = contextParams.index;\n  this.contextCheckers.forEach(function (contextChecker) {\n    var contextName = contextChecker.contextName;\n\n    var openRange = _this4.getContext(contextName).openRange;\n\n    if (!openRange && contextChecker.checkStart(contextParams)) {\n      openRange = new ContextRange(index, null, contextName);\n      _this4.getContext(contextName).openRange = openRange;\n\n      _this4.dispatch('contextStart', [contextName, index]);\n    }\n\n    if (!!openRange && contextChecker.checkEnd(contextParams)) {\n      var offset = index - openRange.startIndex + 1;\n\n      var range = _this4.setEndOffset(offset, contextName);\n\n      _this4.dispatch('contextEnd', [contextName, range]);\n    }\n  });\n};\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\n\n\nTokenizer.prototype.tokenize = function (text) {\n  this.tokens = [];\n  this.resetContextsRanges();\n  var chars = Array.from(text);\n  this.dispatch('start');\n\n  for (var i = 0; i < chars.length; i++) {\n    var char = chars[i];\n    var contextParams = new ContextParams(chars, i);\n    this.dispatch('next', [contextParams]);\n    this.runContextCheck(contextParams);\n    var token = new Token(char);\n    this.tokens.push(token);\n    this.dispatch('newToken', [token, contextParams]);\n  }\n\n  this.dispatch('end', [this.tokens]);\n  return this.tokens;\n};\n\nexport default Tokenizer;\nexport { Token, Event, ContextRange, ContextParams };","map":null,"metadata":{},"sourceType":"module"}