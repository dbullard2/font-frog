{"ast":null,"code":"// The GlyphSet object\nimport Glyph from './glyph'; // Define a property on the glyph that depends on the path being loaded.\n\nfunction defineDependentProperty(glyph, externalName, internalName) {\n  Object.defineProperty(glyph, externalName, {\n    get: function get() {\n      // Request the path property to make sure the path is loaded.\n      glyph.path; // jshint ignore:line\n\n      return glyph[internalName];\n    },\n    set: function set(newValue) {\n      glyph[internalName] = newValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\n\n\nfunction GlyphSet(font, glyphs) {\n  this.font = font;\n  this.glyphs = {};\n\n  if (Array.isArray(glyphs)) {\n    for (var i = 0; i < glyphs.length; i++) {\n      var glyph = glyphs[i];\n      glyph.path.unitsPerEm = font.unitsPerEm;\n      this.glyphs[i] = glyph;\n    }\n  }\n\n  this.length = glyphs && glyphs.length || 0;\n}\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\n\n\nGlyphSet.prototype.get = function (index) {\n  // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n  if (this.glyphs[index] === undefined) {\n    this.font._push(index);\n\n    if (typeof this.glyphs[index] === 'function') {\n      this.glyphs[index] = this.glyphs[index]();\n    }\n\n    var glyph = this.glyphs[index];\n    var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n    if (unicodeObj) {\n      for (var j = 0; j < unicodeObj.unicodes.length; j++) {\n        glyph.addUnicode(unicodeObj.unicodes[j]);\n      }\n    }\n\n    if (this.font.cffEncoding) {\n      if (this.font.isCIDFont) {\n        glyph.name = 'gid' + index;\n      } else {\n        glyph.name = this.font.cffEncoding.charset[index];\n      }\n    } else if (this.font.glyphNames.names) {\n      glyph.name = this.font.glyphNames.glyphIndexToName(index);\n    }\n\n    this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n    this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n  } else {\n    if (typeof this.glyphs[index] === 'function') {\n      this.glyphs[index] = this.glyphs[index]();\n    }\n  }\n\n  return this.glyphs[index];\n};\n/**\n * @param  {number} index\n * @param  {Object}\n */\n\n\nGlyphSet.prototype.push = function (index, loader) {\n  this.glyphs[index] = loader;\n  this.length++;\n};\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\n\n\nfunction glyphLoader(font, index) {\n  return new Glyph({\n    index: index,\n    font: font\n  });\n}\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\n\n\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n  return function () {\n    var glyph = new Glyph({\n      index: index,\n      font: font\n    });\n\n    glyph.path = function () {\n      parseGlyph(glyph, data, position);\n      var path = buildPath(font.glyphs, glyph);\n      path.unitsPerEm = font.unitsPerEm;\n      return path;\n    };\n\n    defineDependentProperty(glyph, 'xMin', '_xMin');\n    defineDependentProperty(glyph, 'xMax', '_xMax');\n    defineDependentProperty(glyph, 'yMin', '_yMin');\n    defineDependentProperty(glyph, 'yMax', '_yMax');\n    return glyph;\n  };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\n\n\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n  return function () {\n    var glyph = new Glyph({\n      index: index,\n      font: font\n    });\n\n    glyph.path = function () {\n      var path = parseCFFCharstring(font, glyph, charstring);\n      path.unitsPerEm = font.unitsPerEm;\n      return path;\n    };\n\n    return glyph;\n  };\n}\n\nexport default {\n  GlyphSet: GlyphSet,\n  glyphLoader: glyphLoader,\n  ttfGlyphLoader: ttfGlyphLoader,\n  cffGlyphLoader: cffGlyphLoader\n};","map":null,"metadata":{},"sourceType":"module"}