{"ast":null,"code":"// The `cmap` table stores the mappings from characters to glyphs.\n// https://www.microsoft.com/typography/OTSPEC/cmap.htm\nimport check from '../check';\nimport parse from '../parse';\nimport table from '../table';\n\nfunction parseCmapTableFormat12(cmap, p) {\n  //Skip reserved.\n  p.parseUShort(); // Length in bytes of the sub-tables.\n\n  cmap.length = p.parseULong();\n  cmap.language = p.parseULong();\n  var groupCount;\n  cmap.groupCount = groupCount = p.parseULong();\n  cmap.glyphIndexMap = {};\n\n  for (var i = 0; i < groupCount; i += 1) {\n    var startCharCode = p.parseULong();\n    var endCharCode = p.parseULong();\n    var startGlyphId = p.parseULong();\n\n    for (var c = startCharCode; c <= endCharCode; c += 1) {\n      cmap.glyphIndexMap[c] = startGlyphId;\n      startGlyphId++;\n    }\n  }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n  // Length in bytes of the sub-tables.\n  cmap.length = p.parseUShort();\n  cmap.language = p.parseUShort(); // segCount is stored x 2.\n\n  var segCount;\n  cmap.segCount = segCount = p.parseUShort() >> 1; // Skip searchRange, entrySelector, rangeShift.\n\n  p.skip('uShort', 3); // The \"unrolled\" mapping from character codes to glyph indices.\n\n  cmap.glyphIndexMap = {};\n  var endCountParser = new parse.Parser(data, start + offset + 14);\n  var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n  var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n  var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n  var glyphIndexOffset = start + offset + 16 + segCount * 8;\n\n  for (var i = 0; i < segCount - 1; i += 1) {\n    var glyphIndex = void 0;\n    var endCount = endCountParser.parseUShort();\n    var startCount = startCountParser.parseUShort();\n    var idDelta = idDeltaParser.parseShort();\n    var idRangeOffset = idRangeOffsetParser.parseUShort();\n\n    for (var c = startCount; c <= endCount; c += 1) {\n      if (idRangeOffset !== 0) {\n        // The idRangeOffset is relative to the current position in the idRangeOffset array.\n        // Take the current offset in the idRangeOffset array.\n        glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2; // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n\n        glyphIndexOffset += idRangeOffset; // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n\n        glyphIndexOffset += (c - startCount) * 2;\n        glyphIndex = parse.getUShort(data, glyphIndexOffset);\n\n        if (glyphIndex !== 0) {\n          glyphIndex = glyphIndex + idDelta & 0xFFFF;\n        }\n      } else {\n        glyphIndex = c + idDelta & 0xFFFF;\n      }\n\n      cmap.glyphIndexMap[c] = glyphIndex;\n    }\n  }\n} // Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\n\n\nfunction parseCmapTable(data, start) {\n  var cmap = {};\n  cmap.version = parse.getUShort(data, start);\n  check.argument(cmap.version === 0, 'cmap table version should be 0.'); // The cmap table can contain many sub-tables, each with their own format.\n  // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n\n  cmap.numTables = parse.getUShort(data, start + 2);\n  var offset = -1;\n\n  for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n    var platformId = parse.getUShort(data, start + 4 + i * 8);\n    var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n\n    if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {\n      offset = parse.getULong(data, start + 4 + i * 8 + 4);\n      break;\n    }\n  }\n\n  if (offset === -1) {\n    // There is no cmap table in the font that we support.\n    throw new Error('No valid cmap sub-tables found.');\n  }\n\n  var p = new parse.Parser(data, start + offset);\n  cmap.format = p.parseUShort();\n\n  if (cmap.format === 12) {\n    parseCmapTableFormat12(cmap, p);\n  } else if (cmap.format === 4) {\n    parseCmapTableFormat4(cmap, p, data, start, offset);\n  } else {\n    throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n  }\n\n  return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n  t.segments.push({\n    end: code,\n    start: code,\n    delta: -(code - glyphIndex),\n    offset: 0,\n    glyphIndex: glyphIndex\n  });\n}\n\nfunction addTerminatorSegment(t) {\n  t.segments.push({\n    end: 0xFFFF,\n    start: 0xFFFF,\n    delta: 1,\n    offset: 0\n  });\n} // Make cmap table, format 4 by default, 12 if needed only\n\n\nfunction makeCmapTable(glyphs) {\n  // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n  var isPlan0Only = true;\n  var i; // Check if we need to add cmap format 12 or if format 4 only is fine\n\n  for (i = glyphs.length - 1; i > 0; i -= 1) {\n    var g = glyphs.get(i);\n\n    if (g.unicode > 65535) {\n      console.log('Adding CMAP format 12 (needed!)');\n      isPlan0Only = false;\n      break;\n    }\n  }\n\n  var cmapTable = [{\n    name: 'version',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'numTables',\n    type: 'USHORT',\n    value: isPlan0Only ? 1 : 2\n  }, // CMAP 4 header\n  {\n    name: 'platformID',\n    type: 'USHORT',\n    value: 3\n  }, {\n    name: 'encodingID',\n    type: 'USHORT',\n    value: 1\n  }, {\n    name: 'offset',\n    type: 'ULONG',\n    value: isPlan0Only ? 12 : 12 + 8\n  }];\n  if (!isPlan0Only) cmapTable = cmapTable.concat([// CMAP 12 header\n  {\n    name: 'cmap12PlatformID',\n    type: 'USHORT',\n    value: 3\n  }, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n  {\n    name: 'cmap12EncodingID',\n    type: 'USHORT',\n    value: 10\n  }, {\n    name: 'cmap12Offset',\n    type: 'ULONG',\n    value: 0\n  }]);\n  cmapTable = cmapTable.concat([// CMAP 4 Subtable\n  {\n    name: 'format',\n    type: 'USHORT',\n    value: 4\n  }, {\n    name: 'cmap4Length',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'language',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'segCountX2',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'searchRange',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'entrySelector',\n    type: 'USHORT',\n    value: 0\n  }, {\n    name: 'rangeShift',\n    type: 'USHORT',\n    value: 0\n  }]);\n  var t = new table.Table('cmap', cmapTable);\n  t.segments = [];\n\n  for (i = 0; i < glyphs.length; i += 1) {\n    var glyph = glyphs.get(i);\n\n    for (var j = 0; j < glyph.unicodes.length; j += 1) {\n      addSegment(t, glyph.unicodes[j], i);\n    }\n\n    t.segments = t.segments.sort(function (a, b) {\n      return a.start - b.start;\n    });\n  }\n\n  addTerminatorSegment(t);\n  var segCount = t.segments.length;\n  var segCountToRemove = 0; // CMAP 4\n  // Set up parallel segment arrays.\n\n  var endCounts = [];\n  var startCounts = [];\n  var idDeltas = [];\n  var idRangeOffsets = [];\n  var glyphIds = []; // CMAP 12\n\n  var cmap12Groups = []; // Reminder this loop is not following the specification at 100%\n  // The specification -> find suites of characters and make a group\n  // Here we're doing one group for each letter\n  // Doing as the spec can save 8 times (or more) space\n\n  for (i = 0; i < segCount; i += 1) {\n    var segment = t.segments[i]; // CMAP 4\n\n    if (segment.end <= 65535 && segment.start <= 65535) {\n      endCounts = endCounts.concat({\n        name: 'end_' + i,\n        type: 'USHORT',\n        value: segment.end\n      });\n      startCounts = startCounts.concat({\n        name: 'start_' + i,\n        type: 'USHORT',\n        value: segment.start\n      });\n      idDeltas = idDeltas.concat({\n        name: 'idDelta_' + i,\n        type: 'SHORT',\n        value: segment.delta\n      });\n      idRangeOffsets = idRangeOffsets.concat({\n        name: 'idRangeOffset_' + i,\n        type: 'USHORT',\n        value: segment.offset\n      });\n\n      if (segment.glyphId !== undefined) {\n        glyphIds = glyphIds.concat({\n          name: 'glyph_' + i,\n          type: 'USHORT',\n          value: segment.glyphId\n        });\n      }\n    } else {\n      // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n      segCountToRemove += 1;\n    } // CMAP 12\n    // Skip Terminator Segment\n\n\n    if (!isPlan0Only && segment.glyphIndex !== undefined) {\n      cmap12Groups = cmap12Groups.concat({\n        name: 'cmap12Start_' + i,\n        type: 'ULONG',\n        value: segment.start\n      });\n      cmap12Groups = cmap12Groups.concat({\n        name: 'cmap12End_' + i,\n        type: 'ULONG',\n        value: segment.end\n      });\n      cmap12Groups = cmap12Groups.concat({\n        name: 'cmap12Glyph_' + i,\n        type: 'ULONG',\n        value: segment.glyphIndex\n      });\n    }\n  } // CMAP 4 Subtable\n\n\n  t.segCountX2 = (segCount - segCountToRemove) * 2;\n  t.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;\n  t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n  t.rangeShift = t.segCountX2 - t.searchRange;\n  t.fields = t.fields.concat(endCounts);\n  t.fields.push({\n    name: 'reservedPad',\n    type: 'USHORT',\n    value: 0\n  });\n  t.fields = t.fields.concat(startCounts);\n  t.fields = t.fields.concat(idDeltas);\n  t.fields = t.fields.concat(idRangeOffsets);\n  t.fields = t.fields.concat(glyphIds);\n  t.cmap4Length = 14 + // Subtable header\n  endCounts.length * 2 + 2 + // reservedPad\n  startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;\n\n  if (!isPlan0Only) {\n    // CMAP 12 Subtable\n    var cmap12Length = 16 + // Subtable header\n    cmap12Groups.length * 4;\n    t.cmap12Offset = 12 + 2 * 2 + 4 + t.cmap4Length;\n    t.fields = t.fields.concat([{\n      name: 'cmap12Format',\n      type: 'USHORT',\n      value: 12\n    }, {\n      name: 'cmap12Reserved',\n      type: 'USHORT',\n      value: 0\n    }, {\n      name: 'cmap12Length',\n      type: 'ULONG',\n      value: cmap12Length\n    }, {\n      name: 'cmap12Language',\n      type: 'ULONG',\n      value: 0\n    }, {\n      name: 'cmap12nGroups',\n      type: 'ULONG',\n      value: cmap12Groups.length / 3\n    }]);\n    t.fields = t.fields.concat(cmap12Groups);\n  }\n\n  return t;\n}\n\nexport default {\n  parse: parseCmapTable,\n  make: makeCmapTable\n};","map":null,"metadata":{},"sourceType":"module"}